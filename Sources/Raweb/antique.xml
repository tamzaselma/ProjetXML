<?xml version="1.0" encoding="utf-8"?>
<raweb xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="en" year="2016">
  <identification id="antique" isproject="true">
    <shortname>ANTIQUE</shortname>
    <projectName>Static Analysis by Abstract Interpretation</projectName>
    <theme-de-recherche>Proofs and Verification</theme-de-recherche>
    <domaine-de-recherche>Algorithmics, Programming, Software and Architecture</domaine-de-recherche>
    <structure_exterieure type="Labs">
      <libelle>Département d'Informatique de l'Ecole Normale Supérieure</libelle>
    </structure_exterieure>
    <structure_exterieure type="Organism">
      <libelle>CNRS</libelle>
    </structure_exterieure>
    <structure_exterieure type="Organism">
      <libelle>Ecole normale supérieure de Paris</libelle>
    </structure_exterieure>
    <header_dates_team>Creation of the Team: 2014 January 01, updated into Project-Team: 2015 April 01</header_dates_team>
    <LeTypeProjet>Project-Team</LeTypeProjet>
    <keywordsSdN>
      <term>2. - Software</term>
      <term>2.1. - Programming Languages</term>
      <term>2.1.1. - Semantics of programming languages</term>
      <term>2.2.1. - Static analysis</term>
      <term>2.3.1. - Embedded systems</term>
      <term>2.4. - Verification, reliability, certification</term>
      <term>2.4.1. - Analysis</term>
      <term>2.4.2. - Model-checking</term>
      <term>2.4.3. - Proofs</term>
      <term>4.4. - Security of equipment and software</term>
      <term>4.5. - Formal methods for security</term>
    </keywordsSdN>
    <keywordsSecteurs>
      <term>1.1. - Biology</term>
      <term>1.1.10. - Mathematical biology</term>
      <term>1.1.11. - Systems biology</term>
      <term>5.2. - Design and manufacturing</term>
      <term>5.2.1. - Road vehicles</term>
      <term>5.2.2. - Railway</term>
      <term>5.2.3. - Aviation</term>
      <term>5.2.4. - Aerospace</term>
      <term>6.1. - Software industry</term>
      <term>6.1.1. - Software engineering</term>
      <term>6.1.2. - Software evolution, maintenance</term>
      <term>6.6. - Embedded systems</term>
    </keywordsSecteurs>
    <UR name="Paris"/>
  </identification>
  <team id="uid1">
    <person key="antique-2014-idm29376">
      <firstname>Xavier</firstname>
      <lastname>Rival</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Team leader, Inria, Senior Researcher</moreinfo>
      <hdr>oui</hdr>
    </person>
    <person key="antique-2014-idm27896">
      <firstname>Patrick</firstname>
      <lastname>Cousot</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris, Professor Emeritus</moreinfo>
      <hdr>oui</hdr>
    </person>
    <person key="antique-2014-idp65608">
      <firstname>Vincent</firstname>
      <lastname>Danos</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>CNRS, Senior Researcher</moreinfo>
      <hdr>oui</hdr>
    </person>
    <person key="antique-2015-idp65272">
      <firstname>Cezara</firstname>
      <lastname>Dragoi</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, Researcher</moreinfo>
    </person>
    <person key="antique-2014-idp67080">
      <firstname>Jérôme</firstname>
      <lastname>Feret</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, Researcher</moreinfo>
    </person>
    <person key="antique-2014-idp76200">
      <firstname>Francois</firstname>
      <lastname>Berenger</lastname>
      <categoryPro>Technique</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="antique-2014-idp78728">
      <firstname>Mehdi</firstname>
      <lastname>Bouaziz</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, until Nov 2016</moreinfo>
    </person>
    <person key="antique-2014-idp79976">
      <firstname>Ferdinanda</firstname>
      <lastname>Camporesi</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="antique-2014-idp81224">
      <firstname>Tie</firstname>
      <lastname>Cheng</lastname>
      <categoryPro>Technique</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, until May 2016</moreinfo>
    </person>
    <person key="deducteam-2014-idp112264">
      <firstname>Kim Quyen</firstname>
      <lastname>Ly</lastname>
      <categoryPro>Technique</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="antique-2014-idp83752">
      <firstname>Huisong</firstname>
      <lastname>Li</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="antique-2016-idp136160">
      <firstname>Jiangchao</firstname>
      <lastname>Liu</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="antique-2016-idp138560">
      <firstname>Hugo</firstname>
      <lastname>Illous</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>CEA, ENS</moreinfo>
    </person>
    <person key="antique-2014-idp87720">
      <firstname>Thibault</firstname>
      <lastname>Suzanne</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris</moreinfo>
    </person>
    <person key="antique-2016-idp143424">
      <firstname>Andreea</firstname>
      <lastname>Beica</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris</moreinfo>
    </person>
    <person key="antique-2016-idp145856">
      <firstname>Patric</firstname>
      <lastname>Fulop</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>University of Edinburgh and ENS Paris</moreinfo>
    </person>
    <person key="antique-2015-idp81536">
      <firstname>Ilias</firstname>
      <lastname>Garnier</lastname>
      <categoryPro>PostDoc</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris and University of Edinburgh</moreinfo>
    </person>
    <person key="antique-2016-idp150784">
      <firstname>Nicolas</firstname>
      <lastname>Behr</lastname>
      <categoryPro>PostDoc</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris and University of Edinburgh</moreinfo>
    </person>
    <person key="antique-2016-idp153264">
      <firstname>Ricardo</firstname>
      <lastname>Honorato-Zimmer</lastname>
      <categoryPro>PostDoc</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris and University of Edinburgh</moreinfo>
    </person>
    <person key="antique-2014-idp71096">
      <firstname>Kwangkeun</firstname>
      <lastname>Yi</lastname>
      <categoryPro>Visiteur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Seoul National University, until Oct 2016</moreinfo>
    </person>
    <person key="cascade-2014-idp97208">
      <firstname>Nathalie</firstname>
      <lastname>Gaudechoux</lastname>
      <categoryPro>Assistant</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
  </team>
  <presentation id="uid2">
    <bodyTitle>Overall Objectives</bodyTitle>
    <subsection id="uid3" level="1">
      <bodyTitle>Overall Objectives</bodyTitle>
      <p>Our group focuses on developing <i>automated</i> techniques to compute
<i>semantic properties</i> of programs and other systems with a
computational semantics in general.
Such properties include (but are not limited to) important classes of
correctness properties.</p>
      <p>Verifying safety critical systems (such as avionics systems) is an important
motivation to compute such properties.
Indeed, a fault in an avionics system, such as a runtime error in the
fly-by-wire command software, may cause an accident, with loss of life.
As these systems are also very complex and are developed by large
teams and maintained over long periods, their verification has became
a crucial challenge.
Safety critical systems are not limited to avionics:
software runtime errors in cruise control management systems were
recently blamed for causing <i>unintended acceleration</i> in certain
Toyota models (the case was settled with a 1.2 billion dollars fine in
March 2014, after years of investigation and several trials).
Similarly, other transportation systems (railway), energy production
systems (nuclear power plants, power grid management), and medical
systems (pacemakers, surgery and patient monitoring systems) rely
on complex software, which should be verified.</p>
      <p>Beyond the field of embedded systems, other pieces of software may cause
very significant harm in case of bugs, as demonstrated by the Heartbleed
security hole: due to a wrong protocol implementation, many websites could
leak private information, over years.</p>
      <p>An important example of semantic properties is the class of <i>safety</i>
properties.
A safety property typically specifies that some (undesirable) event will
never occur, whatever the execution of the program that is considered.
For instance, the absence of runtime error is a very important safety
property.
Other important classes of semantic properties include <i>liveness</i>
properties (i.e., properties that specify that some desirable event will
eventually occur) such as termination and <i>security</i> properties,
such as the absence of information flows from private to public channels.</p>
      <p>All these software semantic properties are <i>not decidable</i>, as can
be shown by reduction to the halting problem.
Therefore, there is no chance to develop any fully automatic technique
able to decide, for any system, whether or not it satisfies some given
semantic property.</p>
      <p>The classic development techniques used in industry involve testing,
which is not sound, as it only gives information about a usually limited
test sample:
even after successful test-based validation, situations that were
untested may generate a problem.
Furthermore, testing is costly in the long term, as it should be re-done
whenever the system to verify is modified.
Machine-assisted verification is another approach which verifies human
specified properties.
However, this approach also presents a very significant cost, as the
annotations required to verify large industrial applications would be
huge.</p>
      <p>By contrast, the <b>antique</b> group focuses on the design of semantic analysis
techniques that should be <i>sound</i> (i.e., compute semantic properties
that are satisfied by all executions) and <i>automatic</i> (i.e., with no
human interaction), although generally <i>incomplete</i> (i.e., not able
to compute the best —in the sense of: most precise— semantic property).
As a consequence of incompleteness, we may fail to verify a system
that is actually correct.
For instance, in the case of verification of absence of runtime error,
the analysis may fail to validate a program, which is safe, and emit
<i>false alarms</i> (that is reports that possibly dangerous operations
were not proved safe), which need to be discharged manually.
Even in this case, the analysis provides information about the
alarm context, which may help disprove it manually or refine the
analysis.</p>
      <p>The methods developed by the <b>antique</b> group are not be limited to the
analysis of software.
We also consider complex biological systems (such as models of
signaling pathways, i.e. cascades of protein interactions, which enable
signal communication among and within cells), described in higher level
languages, and use abstraction techniques to reduce their combinatorial
complexity and capture key properties so as to get a better insight in
the underlying mechanisms of these systems.</p>
    </subsection>
  </presentation>
  <fondements id="uid4">
    <bodyTitle>Research Program</bodyTitle>
    <subsection id="uid5" level="1">
      <bodyTitle>Semantics</bodyTitle>
      <p>Semantics plays a central role in verification since it always serves
as a basis to express the properties of interest, that need to be
verified, but also additional properties, required to prove the
properties of interest, or which may make the design of static analysis
easier.</p>
      <p>For instance, if we aim for a static analysis that should prove the absence
of runtime error in some class of programs, the concrete semantics should
define properly what error states and non error states are, and how program
executions step from a state to the next one.
In the case of a language like C, this includes the behavior of floating
point operations as defined in the IEEE 754 standard.
When considering parallel programs, this includes a model of the scheduler,
and a formalization of the memory model.</p>
      <p>In addition to the properties that are required to express the proof of the
property of interest, it may also be desirable that semantics describe
program behaviors in a finer manner, so as to make static analyses easier
to design.
For instance, it is well known that, when a state property (such as the
absence of runtime error) is valid, it can be established using only a
state invariant (i.e., an invariant that ignores the order in which states
are visited during program executions).
Yet searching for trace invariants (i.e., that take into account some
properties of program execution history) may make the static analysis
significantly easier, as it will allow it to make finer case splits,
directed by the history of program executions.
To allow for such powerful static analyses, we often resort to a
<i>non standard semantics</i>, which incorporates properties that would
normally be left out of the concrete semantics.
</p>
    </subsection>
    <subsection id="uid6" level="1">
      <bodyTitle>Abstract interpretation and static analysis</bodyTitle>
      <p>Once a reference semantics has been fixed and a property of interest has
been formalized, the definition of a static analysis requires the choice
of an <i>abstraction</i>.
The abstraction ties a set of <i>abstract predicates</i> to the concrete
ones, which they denote.
This relation is often expressed with a <i>concretization function</i>
that maps each abstract element to the concrete property it stands for.
Obviously, a well chosen abstraction should allow expressing the property
of interest, as well as all the intermediate properties that are required
in order to prove it (otherwise, the analysis would have no chance to
achieve a successful verification).
It should also lend itself to an efficient implementation, with efficient
data-structures and algorithms for the representation and the manipulation
of abstract predicates.
A great number of abstractions have been proposed for all kinds of
concrete data types, yet the search for new abstractions is a very
important topic in static analysis, so as to target novel kinds of
properties, to design more efficient or more precise static
analyses.</p>
      <p>Once an abstraction is chosen, a set of <i>sound abstract transformers</i>
can be derived from the concrete semantics and that account for individual
program steps, in the abstract level and without forgetting any concrete
behavior.
A static analysis follows as a result of this step by step approximation
of the concrete semantics, when the abstract transformers are all
computable.
This process defines an <i>abstract interpretation</i>  <ref xlink:href="#antique-2016-bid0" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.
The case of loops requires a bit more work as the concrete semantics
typically relies on a fixpoint that may not be computable in finitely
many iterations.
To achieve a terminating analysis we then use <i>widening
operators</i>  <ref xlink:href="#antique-2016-bid0" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, which over-approximates the concrete
union and ensure termination.</p>
      <p>A static analysis defined that way always terminates and produces sound
over-approximations of the programs behaviors.
Yet, these results may not be precise enough for verification.
This is where the art of static analysis design comes into play
through, among others:</p>
      <simplelist>
        <li id="uid7">
          <p noindent="true">the use of more precise, yet still efficient enough abstract domains;</p>
        </li>
        <li id="uid8">
          <p noindent="true">the combination of application specific abstract domains;</p>
        </li>
        <li id="uid9">
          <p noindent="true">the careful choice of abstract transformers and widening operators.</p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid10" level="1">
      <bodyTitle>Applications of the notion of
abstraction in semantics</bodyTitle>
      <p>In the previous subsections, we sketched the steps in the design of a
static analyzer to infer some family of properties, which should be
implementable, and efficient enough to succeed in verifying non trivial
systems.</p>
      <p>Yet, the same principles can also be applied successfully to other goals.
In particular, the abstract interpretation framework should be viewed a
very general tool to <i>compare different semantics</i>, not necessarily
with the goal of deriving a static analyzer.
Such comparisons may be used in order to prove two semantics equivalent
(i.e., one is an abstraction of the other and vice versa), or that a first
semantics is strictly more expressive than another one (i.e., the latter
can be viewed an abstraction of the former, where the abstraction actually
makes some information redundant, which cannot be recovered).
A classical example of such comparison is the classification of semantics
of transition systems  <ref xlink:href="#antique-2016-bid1" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, which provides a better
understanding of program semantics in general.
For instance, this approach can be applied to get a better understanding
of the semantics of a programming language, but also to select which
concrete semantics should be used as a foundation for a static analysis,
or to prove the correctness of a program transformation, compilation or
optimization.
</p>
    </subsection>
    <subsection id="uid11" level="1">
      <bodyTitle>The analysis of biological models</bodyTitle>
      <p>One of our application domains, the analysis of biological models, is
not a classical target of static analysis because it aims at analyzing
models instead of programs.
Yet, the analysis of biological models is closely intertwined with the other
application fields of our group.
Firstly, abstract interpretation provides a formal understanding of the
abstraction process which is inherent to the modeling process.
Abstract interpretation is also used to better understand the systematic
approaches which are used in the systems biology field to capture the
properties of models, until getting formal, fully automatic, and scalable
methods.
Secondly, abstract interpretation is used to offer various semantics with
different grains of abstraction, and, thus, new methods to apprehend the
overall behavior of the models.
Conversely, some of the methods and abstractions which are developed for
biological models are inspired by the analysis of concurrent systems
and by security analysis.
Lastly, the analysis of biological models raises issues about differential
systems, stochastic systems, and hybrid systems.
Any breakthrough in these directions will likely be very important
to address the important challenge of the certification of critical
systems in interaction with their physical environment.
</p>
    </subsection>
  </fondements>
  <domaine id="uid12">
    <bodyTitle>Application Domains</bodyTitle>
    <subsection id="uid13" level="1">
      <bodyTitle>Verification of safety critical
embedded software</bodyTitle>
      <p>The verification of safety critical embedded software is a very
important application domain for our group.
First, this field requires a high confidence in software, as a bug may
cause disastrous events.
Thus, it offers an obvious opportunity for a strong impact.
Second, such software usually have better specifications and a better
design than many other families of software, hence are an easier target
for developing new static analysis techniques (which can later be
extended for more general, harder to cope with families of programs).
This includes avionics, automotive and other transportation systems,
medical systems...</p>
      <p>For instance, the verification of avionics systems represent a very
high percentage of the cost of an airplane (about 30 % of the overall
airplane design cost).
The state of the art development processes mainly resort to testing
in order to improve the quality of software.
Depending on the level of criticality of a software (at highest levels,
any software failure would endanger the flight) a set of software
requirements are checked with test suites.
This approach is both costly (due to the sheer amount of testing that
needs to be performed) and unsound (as errors may go unnoticed, if they
do not arise on the test suite).</p>
      <p>By contrast, static analysis can ensure higher software quality at a
lower cost.
Indeed, a static analyzer will catch all bugs of a certain kind.
Moreover, a static analysis run typically lasts a few hours, and
can be integrated in the development cycle in a seamless manner.
For instance, <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">Astrée</span></ref> successfully verified the absence of runtime
error in several families of safety critical fly-by-wire avionic
software, in at most a day of computation, on standard hardware.
Other kinds of synchronous embedded software have also been analyzed
with good results.</p>
      <p>In the future, we plan to greatly extend this work so as to verify
<i>other families of embedded software</i> (such as communication,
navigation and monitoring software) and <i>other families of properties</i>
(such as security and liveness properties).</p>
      <p>Embedded software in charge of communication, navigation, monitoring
typically rely on a <i>parallel</i> structure, where several threads are
executed in parallel, and manage different features (input, output,
user interface, internal computation, logging...).
This structure is also often found in automotive software.
An even more complex case is that of <i>distributed</i> systems, where
several separate computers are run in parallel and take care of several
sub-tasks of a same feature, such as braking.
Such a logical structure is not only more complex than the synchronous
one, but it also introduces new risks and new families of errors
(deadlocks, data-races...).
Moreover, such less well designed, and more complex embedded software
often utilizes more complex data-structures than synchronous programs
(which typically only use arrays to store previous states)
and may use dynamic memory allocation, or build dynamic structures
inside static memory regions, which are actually even harder to
verify than conventional dynamically allocated data structures.
Complex data-structures also introduce new kinds of risks (the failure
to maintain structural invariants may lead to runtime errors, non
termination, or other software failures).
To verify such programs, we will design additional abstract domains, and
develop new static analysis techniques, in order to support the
analysis of more complex programming language features such as
parallel and concurrent programming with threads and manipulations of
complex data structures.
Due to their size and complexity, the verification of such families of
embedded software is a major challenge for the research community.</p>
      <p>Furthermore, embedded systems also give rise to novel security concerns.
It is in particular the case for some aircraft-embedded computer systems,
which communicate with the ground through untrusted communication media.
Besides, the increasing demand for new capabilities, such as enhanced
on-board connectivity, e.g. using mobile devices, together with the need
for cost reduction, leads to more integrated and interconnected systems.
For instance, modern aircrafts embed a large number of computer systems,
from safety-critical cockpit avionics to passenger entertainment.
Some systems meet both safety and security requirements.
Despite thorough segregation of subsystems and networks, some shared
communication resources raise the concern of possible intrusions.
Because of the size of such systems, and considering that they are evolving
entities, the only economically viable alternative is to perform automatic
analyses.
Such analyses of security and confidentiality properties have never been
achieved on large-scale systems where security properties interact with
other software properties, and even the mapping between high-level models
of the systems and the large software base implementing them has never
been done and represents a great challenge.
Our goal is to prove empirically that the security of such large scale
systems can be proved formally, thanks to the design of dedicated abstract
interpreters.</p>
      <p>The long term goal is to make static analysis more widely applicable
to the verification of industrial software.
</p>
    </subsection>
    <subsection id="uid14" level="1">
      <bodyTitle>Static analysis of software components
and libraries</bodyTitle>
      <p>An important goal of our work is to make static analysis techniques
easier to apply to wider families of software.
Then, in the longer term, we hope to be able to verify less critical,
yet very commonly used pieces of software.
Those are typically harder to analyze than critical software, as their
development process tends to be less rigorous.
In particular, we will target operating systems components and libraries.
As of today, the verification of such programs is considered a major
challenge to the static analysis community.</p>
      <p>As an example, most programming languages offer Application Programming
Interfaces (API) providing ready-to-use abstract data structures (e.g.,
sets, maps, stacks, queues, etc.).
These APIs, are known under the name of containers or collections, and
provide off-the-shelf libraries of high level operations, such as
insertion, deletion and membership checks.
These container libraries give software developers a way of abstracting
from low-level implementation details related to memory management, such
as dynamic allocation, deletion and pointer handling or concurrency
aspects, such as thread synchronization.
Libraries implementing data structures are important building bricks of a
huge number of applications, therefore their verification is paramount.
We are interested in developing static analysis techniques that will prove
automatically the correctness of large audience libraries such as Glib and
Threading Building Blocks.
</p>
    </subsection>
    <subsection id="uid15" level="1">
      <bodyTitle>Biological systems</bodyTitle>
      <p>Computer Science takes a more and more important role in the design and
the understanding of biological systems such as signaling pathways, self
assembly systems, DNA repair mechanisms.
Biology has gathered large data-bases of facts about mechanistic
interactions between proteins, but struggles to draw an overall picture
of how these systems work as a whole.
High level languages designed in Computer Science allow to collect these
interactions in integrative models, and provide formal definitions (i.e.,
semantics) for the behavior of these models.
This way, modelers can encode their knowledge, following a bottom-up
discipline, without simplifying <i>a priori</i> the models at the risk
of damaging the key properties of the system.
Yet, the systems that are obtained this way suffer from combinatorial
explosion (in particular, in the number of different kinds of molecular
components, which can arise at run-time), which prevents from a naive
computation of their behavior.</p>
      <p>We develop various abstract interpretation-based analyses, tailored to
different phases of the modeling process.
We propose automatic static analyses in order to detect inconsistencies in
the early phases of the modeling process.
These analyses are similar to the analysis of classical safety
properties of programs.
They involve both forward and backward reachability analyses as well as
causality analyses, and can be tuned at different levels of abstraction.
We also develop automatic static analyses so as to identify the key elements
in the dynamics of these models.
The results of these analyses are sent to another tool,
which is used to automatically simplify the models.
The correctness of this simplification process is proved by
the means of abstract interpretation: this ensures formally
that the simplification preserves the quantitative properties
that have been specified beforehand by the modeler.
The whole pipeline is parameterized by a large choice of abstract domains
which exploits different features of the high level description of
models.
</p>
    </subsection>
  </domaine>
  <highlights id="uid16">
    <bodyTitle>Highlights of the Year</bodyTitle>
    <subsection id="uid17" level="1">
      <bodyTitle>Highlights of the Year</bodyTitle>
      <p>The team obtained several strong results published in excellent international conferences, with high theoretical and applied impact(see detailed results). Among the theoretical results we underline those presented in conferences like Principles of programming languages POPL 2016, and among the applied results we underline the release of MemCad, the first analyzer that can handle the analysis of various data structures.</p>
    </subsection>
  </highlights>
  <logiciels id="uid18">
    <bodyTitle>New Software and Platforms</bodyTitle>
    <subsection id="uid19" level="1">
      <bodyTitle>APRON</bodyTitle>
      <p>
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>The APRON library is intended to be a common interface to various
underlying libraries/abstract domains and to provide additional
services that can be implemented independently from the underlying
library/abstract domain, as shown by the poster on the right
(presented at the SAS 2007 conference. You may also look at:</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>The Apron library is dedicated to the static analysis of the
numerical variables of a program by abstract interpretation.
Its goal is threefold: provide ready-to-use numerical abstractions
under a common API for analysis implementers, encourage the research
in numerical abstract domains by providing a platform for integration
and comparison of domains, and provide a teaching and demonstration
tool to disseminate knowledge on abstract interpretation.</p>
      <simplelist>
        <li id="uid20">
          <p noindent="true">Participants: Antoine Miné and Bertrand Jeannet</p>
        </li>
        <li id="uid21">
          <p noindent="true">Contact: Antoine Miné</p>
        </li>
        <li id="uid22">
          <p noindent="true">URL: <ref xlink:href="http://apron.cri.ensmp.fr/library/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>apron.<allowbreak/>cri.<allowbreak/>ensmp.<allowbreak/>fr/<allowbreak/>library/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid23" level="1">
      <bodyTitle>Astrée</bodyTitle>
      <p>
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>Astrée analyzes structured C programs, with complex memory usages,
but without dynamic memory allocation nor recursion.
This encompasses many embedded programs as found in earth transportation,
nuclear energy, medical instrumentation, and aerospace applications, in
particular synchronous control/command. The whole analysis process is
entirely automatic.</p>
      <p>Astrée discovers all runtime errors including:</p>
      <simplelist>
        <li id="uid24">
          <p noindent="true">undefined behaviors in the terms of the ANSI C99 norm of the C
language (such as division by 0 or out of bounds array indexing),</p>
        </li>
        <li id="uid25">
          <p noindent="true">any violation of the implementation-specific behavior as defined
in the relevant Application Binary Interface (such as the size of
integers and arithmetic overflows),</p>
        </li>
        <li id="uid26">
          <p noindent="true">any potentially harmful or incorrect use of C violating optional
user-defined programming guidelines (such as no modular arithmetic for
integers, even though this might be the hardware choice),</p>
        </li>
        <li id="uid27">
          <p noindent="true">failure of user-defined assertions.</p>
        </li>
      </simplelist>
      <p>
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>Astrée is a static analyzer for sequential programs based on abstract
interpretation.
The Astrée static analyzer aims at proving the absence of runtime errors
in programs written in the C programming language.</p>
      <simplelist>
        <li id="uid28">
          <p noindent="true">Participants: Patrick Cousot, Radhia Cousot, Jérôme Feret, Laurent
Mauborgne, Antoine Miné and Xavier Rival</p>
        </li>
        <li id="uid29">
          <p noindent="true">Partner: CNRS</p>
        </li>
        <li id="uid30">
          <p noindent="true">Contact: Patrick Cousot</p>
        </li>
        <li id="uid31">
          <p noindent="true">URL: <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>astree.<allowbreak/>ens.<allowbreak/>fr/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid32" level="1">
      <bodyTitle>AstréeA</bodyTitle>
      <p>The AstréeA Static Analyzer of Asynchronous Software</p>
      <p noindent="true">
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>AstréeA analyzes C programs composed of a fixed set of threads that
communicate through a shared memory and synchronization primitives
(mutexes, FIFOs, blackboards, etc.), but without recursion nor dynamic
creation of memory, threads nor synchronization objects. AstréeA
assumes a real-time scheduler, where thread scheduling strictly obeys
the fixed priority of threads. Our model follows the ARINC 653 OS
specification used in embedded industrial aeronautic
software. Additionally, AstréeA employs a weakly-consistent memory
semantics to model memory accesses not protected by a mutex, in order
to take into account soundly hardware and compiler-level program
transformations (such as optimizations). AstréeA checks for the same
run-time errors as Astrée , with the addition of data-races.</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>AstréeA is a static analyzer prototype for parallel software based on
abstract interpretation. The AstréeA prototype is a fork of the
Astrée static analyzer that adds support for analyzing parallel
embedded C software.</p>
      <simplelist>
        <li id="uid33">
          <p noindent="true">Participants: Patrick Cousot, Radhia Cousot, Jérôme Feret,
Antoine Miné and Xavier Rival est toujours membre de Inria. logiciels Inria): https://bil.inria.fr/</p>
        </li>
        <li id="uid34">
          <p noindent="true">Contact: Patrick Cousot</p>
        </li>
        <li id="uid35">
          <p noindent="true">URL: <ref xlink:href="http://www.astreea.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>astreea.<allowbreak/>ens.<allowbreak/>fr/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid36" level="1">
      <bodyTitle>ClangML</bodyTitle>
      <p>
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>ClangML is an OCaml binding with the Clang front-end of the LLVM
compiler suite. Its goal is to provide an easy to use solution to
parse a wide range of C programs, that can be called from static
analysis tools implemented in OCaml, which allows to test them on
existing programs written in C (or in other idioms derived from C)
without having to redesign a front-end from scratch. ClangML features
an interface to a large set of internal AST nodes of Clang , with an
easy to use API. Currently, ClangML supports all C language AST nodes,
as well as a large part of the C nodes related to C++ and
Objective-C.</p>
      <simplelist>
        <li id="uid37">
          <p noindent="true">Participants: François Berenger, Pippijn Van Steenhoven
and Devin Mccoughlin toujours membre de Inria. Inria): https://bil.inria.fr/</p>
        </li>
        <li id="uid38">
          <p noindent="true">Contact: François Berenger</p>
        </li>
        <li id="uid39">
          <p noindent="true">URL:
<ref xlink:href="https://github.com/Antique-team/clangml/tree/master/clang" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>github.<allowbreak/>com/<allowbreak/>Antique-team/<allowbreak/>clangml/<allowbreak/>tree/<allowbreak/>master/<allowbreak/>clang</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid40" level="1">
      <bodyTitle>FuncTion</bodyTitle>
      <p>
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>FuncTion is based on an extension to liveness properties of the
framework to analyze termination by abstract interpretation proposed
by Patrick Cousot and Radhia Cousot. FuncTion infers ranking functions
using piecewise-defined abstract domains. Several domains are
available to partition the ranking function, including intervals,
octagons, and polyhedra. Two domains are also available to represent
the value of ranking functions: a domain of affine ranking functions,
and a domain of ordinal-valued ranking functions (which allows
handling programs with unbounded non-determinism).</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>FuncTion is a research prototype static analyzer to analyze the
termination and functional liveness properties of programs. It accepts
programs in a small non-deterministic imperative language. It is also
parameterized by a property: either termination, or a recurrence or a
guarantee property (according to the classification by Manna and
Pnueli of program properties). It then performs a backward static
analysis that automatically infers sufficient conditions at the
beginning of the program so that all executions satisfying the
conditions also satisfy the property.</p>
      <simplelist>
        <li id="uid41">
          <p noindent="true">Participants: Caterina Urban and Antoine Miné</p>
        </li>
        <li id="uid42">
          <p noindent="true">Contact: Caterina Urban</p>
        </li>
        <li id="uid43">
          <p noindent="true">URL: <ref xlink:href="http://www.di.ens.fr/~urban/FuncTion.html" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>di.<allowbreak/>ens.<allowbreak/>fr/<allowbreak/>~urban/<allowbreak/>FuncTion.<allowbreak/>html</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid44" level="1">
      <bodyTitle>MemCAD</bodyTitle>
      <p>The MemCAD static analyzer</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>MemCAD is a static analyzer that focuses on memory abstraction. It
takes as input C programs, and computes invariants on the data
structures manipulated by the programs. It can also verify memory
safety. It comprises several memory abstract domains, including a flat
representation, and two graph abstractions with summaries based on
inductive definitions of data-structures, such as lists and trees and
several combination operators for memory abstract domains
(hierarchical abstraction, reduced product). The purpose of this
construction is to offer a great flexibility in the memory
abstraction, so as to either make very efficient static analyses of
relatively simple programs, or still quite efficient static analyses
of very involved pieces of code. The implementation consists of over
30 000 lines of ML code, and relies on the ClangML front-end. The
current implementation comes with over 350 small size test cases that
are used as regression tests.</p>
      <simplelist>
        <li id="uid45">
          <p noindent="true">Participants: Antoine Toubhans, Huisong Li, François
Berenger and Xavier Rival</p>
        </li>
        <li id="uid46">
          <p noindent="true">Contact: Xavier Rival</p>
        </li>
        <li id="uid47">
          <p noindent="true">URL: <ref xlink:href="http://www.di.ens.fr/~rival/memcad.html" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>di.<allowbreak/>ens.<allowbreak/>fr/<allowbreak/>~rival/<allowbreak/>memcad.<allowbreak/>html</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid48" level="1">
      <bodyTitle>OPENKAPPA</bodyTitle>
      <p>La platte-forme de modélisation OpenKappa</p>
      <p noindent="true"><span class="smallcap" align="left">Keywords:</span> Systems Biology - Modeling - Static analysis -
Simulation - Model reduction</p>
      <p noindent="true">
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>OpenKappa is a collection of tools to build, debug
and run models of biological pathways. It contains a compiler for the
Kappa Language, a static analyzer (for debugging models), a simulator,
a compression tool for causal traces, and a model reduction tool.</p>
      <simplelist>
        <li id="uid49">
          <p noindent="true">Participants: Pierre Boutillier, Vincent Danos, Jérôme
Feret, Walter Fontana, Russ Harmer, Jean Krivine and Kim Quyen Ly</p>
        </li>
        <li id="uid50">
          <p noindent="true">Partners: ENS Lyon - Université Paris-Diderot - Harvard Medical School</p>
        </li>
        <li id="uid51">
          <p noindent="true">Contact: Jérôme Feret</p>
        </li>
        <li id="uid52">
          <p noindent="true">URL: <ref xlink:href="http://www.kappalanguage.org/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>kappalanguage.<allowbreak/>org/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid53" level="1">
      <bodyTitle>QUICr</bodyTitle>
      <p>
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>QUICr is an OCaml library that implements a parametric abstract domain
for sets. It is constructed as a functor that accepts any numeric
abstract domain that can be adapted to the interface and produces an
abstract domain for sets of numbers combined with numbers. It is
relational, flexible, and tunable. It serves as a basis for future
exploration of set abstraction.</p>
      <simplelist>
        <li id="uid54">
          <p noindent="true">Participant: Arlen Cox</p>
        </li>
        <li id="uid55">
          <p noindent="true">Contact: Arlen Cox</p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid56" level="1">
      <bodyTitle>Translation
Validation</bodyTitle>
      <p>
        <span class="smallcap" align="left">Scientific Description</span>
      </p>
      <p>The compilation certification process is performed automatically,
thanks to a prover designed specifically. The automatic proof is done
at a level of abstraction which has been defined so that the result of
the proof of equivalence is strong enough for the goals mentioned
above and so that the proof obligations can be solved by efficient
algorithms.</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>Abstract interpretation, Certified compilation, Static analysis,
Translation validation, Verifier. The main goal of this software
project is to make it possible to certify automatically the
compilation of large safety critical software, by proving that the
compiled code is correct with respect to the source code: When the
proof succeeds, this guara Furthermore, this approach should allow to
meet some domain specific software qualification criteria (such as
those in DO-178 regulations for avionics software), since it allows
proving that successive development levels are correct with respect to
each other i.e., that they implement the same specification. Last,
this technique also justifies the use of source level static analyses,
even when an assembly level certification would be required, since it
establishes separately that the source and the compiled code are
equivalent.ntees that no compiler bug did cause incorrect code to be
generated.</p>
      <simplelist>
        <li id="uid57">
          <p noindent="true">Participant: Xavier Rival</p>
        </li>
        <li id="uid58">
          <p noindent="true">Contact: Xavier Rival</p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid59" level="1">
      <bodyTitle>Zarith</bodyTitle>
      <p>
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>Zarith is a small (10K lines) OCaml library that implements arithmetic
and logical operations over arbitrary-precision integers. It is based
on the GNU MP library to efficiently implement arithmetic over big
integers. Special care has been taken to ensure the efficiency of the
library also for small integers: small integers are represented as
Caml unboxed integers and use a specific C code path. Moreover,
optimized assembly versions of small integer operations are provided
for a few common architectures.</p>
      <p>Zarith is currently used in the Astrée analyzer to enable the sound
analysis of programs featuring 64-bit (or larger) integers. It is also
used in the Frama-C analyzer platform developed at CEA LIST and Inria
Saclay.</p>
      <simplelist>
        <li id="uid60">
          <p noindent="true">Participants: Antoine Miné, Xavier Leroy and Pascal Cuoq</p>
        </li>
        <li id="uid61">
          <p noindent="true">Contact: Antoine Miné</p>
        </li>
        <li id="uid62">
          <p noindent="true">URL: <ref xlink:href="http://forge.ocamlcore.org/projects/zarith" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>forge.<allowbreak/>ocamlcore.<allowbreak/>org/<allowbreak/>projects/<allowbreak/>zarith</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid63" level="1">
      <bodyTitle>CELIA</bodyTitle>
      <p>The MemCAD static analyzer</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>CELIA is a tool for the static analysis and verification of C programs manipulating dynamic lists.
The static analyzer computes for each control point of a C program the assertions which are true (i.e., invariant) at this control point.
The specification language is a combination of Separation Logic with a first order logic over sequences of integers.
The inferred properties describe the shape of the lists, their size, the relations between the data (or the sum, or the multiset of data) in list cells.
The analysis is inter-procedural, i.e., the assertions computed relate the procedure local heap on entry to the corresponding local heap on exit of the procedure.
The results of the analysis can provide insights about equivalence of procedures on lists or null pointer dereferencing.
The analysis is currently extended to programs manipulating concurrent data structures.</p>
      <simplelist>
        <li id="uid64">
          <p noindent="true">Participants: Ahmed Bouajjani, Cezara Drăgoi, Constantin Enea, Mihaela Sighireanu</p>
        </li>
        <li id="uid65">
          <p noindent="true">Contact: Cezara Drăgoi</p>
        </li>
        <li id="uid66">
          <p noindent="true">URL: <ref xlink:href="http://www.liafa.jussieu.fr/celia/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>liafa.<allowbreak/>jussieu.<allowbreak/>fr/<allowbreak/>celia/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid67" level="1">
      <bodyTitle>DAFT</bodyTitle>
      <p>DAFT</p>
      <p noindent="true">
        <span class="smallcap" align="left">Functional Description</span>
      </p>
      <p>DAFT is a distributed file management system in user-space,
with a command-line interface.
DAFT is intended at computational scientists, involved in
data-intensive, distributed experiments and when no distributed file-system
is available on computing nodes.
DAFT is secure; all messages are cryptographically signed
and encrypted by default.</p>
      <simplelist>
        <li id="uid68">
          <p noindent="true">Participants: Francois Berenger and Camille Coti.</p>
        </li>
        <li id="uid69">
          <p noindent="true">Contact: Francois Berenger and Camille Coti.</p>
        </li>
        <li id="uid70">
          <p noindent="true">URL: <ref xlink:href="https://github.com/UnixJunkie/daft" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>github.<allowbreak/>com/<allowbreak/>UnixJunkie/<allowbreak/>daft</ref>.</p>
        </li>
      </simplelist>
    </subsection>
  </logiciels>
  <resultats id="uid71">
    <bodyTitle>New Results</bodyTitle>
    <subsection id="uid72" level="1">
      <bodyTitle>Memory Abstraction</bodyTitle>
      <subsection id="uid73" level="2">
        <bodyTitle>Abstraction of arrays based on non contiguous partitions</bodyTitle>
        <participants>
          <person key="antique-2016-idp136160">
            <firstname>Jiangchao</firstname>
            <lastname>Liu</lastname>
          </person>
          <person key="antique-2014-idm29376">
            <firstname>Xavier</firstname>
            <lastname>Rival</lastname>
            <moreinfo>correspondant</moreinfo>
          </person>
        </participants>
        <p>Abstract interpretation,
Memory abstraction,
Array abstract domains.

In <ref xlink:href="#antique-2016-bid2" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, we studied array abstractions.</p>
        <p>Array partitioning analyses split arrays into contiguous partitions to
infer properties of cell sets.
Such analyses cannot group together non contiguous cells, even when they
have similar properties.
We proposed an abstract domain which utilizes semantic properties to split
array cells into groups.
Cells with similar properties will be packed into groups and abstracted
together.
Additionally, groups are not necessarily contiguous.
This abstract domain allows to infer complex array invariants in a fully
automatic way.
Experiments on examples from the Minix 1.1 memory management demonstrated
its effectiveness.
</p>
      </subsection>
    </subsection>
    <subsection id="uid74" level="1">
      <bodyTitle>Rule-based modeling</bodyTitle>
      <subsection id="uid75" level="2">
        <bodyTitle>Reachability analysis via orthogonal sets of patterns</bodyTitle>
        <participants>
          <person key="deducteam-2014-idp112264">
            <firstname>Kim Quyên</firstname>
            <lastname>Ly</lastname>
          </person>
          <person key="antique-2014-idp67080">
            <firstname>Jérôme</firstname>
            <lastname>Feret</lastname>
            <moreinfo>correspondant</moreinfo>
          </person>
        </participants>
        <p>Rule-based modeling languages, as Kappa, allow for the description of very detailed mechanistic models. Yet, as the rules become more and more numerous, there is a need for formal methods to enhance the level of confidence in the models that are described with these languages. We develop abstract interpretation tools to capture invariants about the biochemical structure of bio-molecular species that may occur in a given model. In previous works, we have focused on the relationships between the states of the sites that belong to a same instance of a protein. This comes down to detect for a specific set of patterns, which ones may be reachable during the execution of the model. This paper <ref xlink:href="#antique-2016-bid3" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, we generalize this approach to a broader family of abstract domains, that we call orthogonal sets of patterns. More precisely, an orthogonal set of patterns is obtained by refining recursively the information about some patterns containing a given protein, so as to partition of the set of occurrences of this protein in any mixture.</p>
      </subsection>
      <subsection id="uid76" level="2">
        <bodyTitle>Local traces: an over-approximation of the behaviour of the proteins in rule-based models</bodyTitle>
        <participants>
          <person key="deducteam-2014-idp112264">
            <firstname>Kim Quyên</firstname>
            <lastname>Ly</lastname>
          </person>
          <person key="antique-2014-idp67080">
            <firstname>Jérôme</firstname>
            <lastname>Feret</lastname>
            <moreinfo>correspondant</moreinfo>
          </person>
        </participants>
        <p>Thanks to rule-based modelling languages, we can assemble large sets of mechanistic protein-protein interactions within integrated models. Our goal would be to understand how the behaviour of these systems emerges from these low-level interactions. Yet this is a quite long term challenge and it is desirable to offer intermediary levels of abstraction, so as to get a better understanding of the models and to increase our confidence within our mechanistic assumptions.
In this paper <ref xlink:href="#antique-2016-bid4" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, we propose an abstract interpretation of the behaviour of each protein, in isolation. Given a model written in Kappa, this abstraction computes for each kind of protein a transition system that describes which conformations this protein can take and how a protein can pass from one conformation to another one. Then, we use simplicial complexes to abstract away the interleaving order of the transformations between conformations that commute. As a result, we get a compact summary of the potential behaviour of each protein of the model.
</p>
      </subsection>
    </subsection>
    <subsection id="uid77" level="1">
      <bodyTitle>Formal Derivation of Qualitative Dynamical Models from Biochemical Networks</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Wassim</firstname>
          <lastname>Abou-Jaoudé</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Denis</firstname>
          <lastname>Thieffry</lastname>
        </person>
        <person key="antique-2014-idp67080">
          <firstname>Jérôme</firstname>
          <lastname>Feret</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>As technological advances allow a better identification of cellular networks, more and more molecular data are produced allowing the construction of detailed molecular interaction maps. One strategy to get insights into the dynamical properties of such systems is to derive compact dynamical models from these maps, in order to ease the analysis of their dynamics. Starting from a case study, we present in <ref xlink:href="#antique-2016-bid5" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> a methodology for the derivation of qualitative dynamical models from biochemical networks. Properties are formalised using abstract interpretation. We first abstract states and traces by quotienting the number of instances of chemical species by intervals. Since this abstraction is too coarse to reproduce the properties of interest, we refine it by introducing additional constraints. The resulting abstraction is able to identify the dynamical properties of interest in our case study.</p>
    </subsection>
    <subsection id="uid78" level="1">
      <bodyTitle>Taking Static Analysis to the Next Level: Proving the Absence of Run-Time Errors and Data Races with Astrée</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Antoine</firstname>
          <lastname>Miné</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Laurent</firstname>
          <lastname>Mauborgne</lastname>
        </person>
        <person key="antique-2014-idm29376">
          <firstname>Xavier</firstname>
          <lastname>Rival</lastname>
        </person>
        <person key="antique-2014-idp67080">
          <firstname>Jérôme</firstname>
          <lastname>Feret</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="antique-2014-idm27896">
          <firstname>Patrick</firstname>
          <lastname>Cousot</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Daniel</firstname>
          <lastname>Kästner</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Stephan</firstname>
          <lastname>Wilhelm</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Christian</firstname>
          <lastname>Ferdinand</lastname>
        </person>
      </participants>
      <p>In <ref xlink:href="#antique-2016-bid6" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, we present an extension of Astrée to concurrent C software. Astrée is a sound static analyzer for run-time errors previously limited to sequential C software. Our extension employs a scalable abstraction which covers all possible thread interleavings, and soundly reports all run-time errors and data races: when the analyzer does not report any alarm, the program is proven free from those classes of errors. We show how this extension is able to support a variety of operating systems (such as POSIX threads, ARINC 653, OSEK/AUTOSAR) and report on experimental results obtained on concurrent software from different domains, including large industrial software.</p>
    </subsection>
    <subsection id="uid79" level="1">
      <bodyTitle>Stochastic mechanics of graph rewriting</bodyTitle>
      <participants>
        <person key="antique-2016-idp150784">
          <firstname>Nicolas</firstname>
          <lastname>Behr</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>We propose an algebraic approach to stochastic graph-rewriting which extends the classical construction of the Heisenberg-Weyl algebra and its canonical representation on the Fock space. Rules are seen as particular elements of an algebra of “diagrams": the diagram algebra D. Diagrams can be thought of as formal computational traces represented in partial time. They can be evaluated to normal diagrams (each corresponding to a rule) and generate an associative unital non-commutative algebra of rules: the rule algebra R. Evaluation becomes a morphism of unital associative algebras which maps general diagrams in D to normal ones in R. In this algebraic reformulation, usual distinctions between graph observables (real-valued maps on the set of graphs defined by counting subgraphs) and rules disappear. Instead, natural algebraic substructures of R arise: formal observables are seen as rules with equal left and right hand sides and form a commutative subalgebra, the ones counting subgraphs forming a sub-subalgebra of identity rules. Actual graph-rewriting is recovered as a canonical representation of the rule algebra as linear operators over the vector space generated by (isomorphism classes of) finite graphs. The construction of the representation is in close analogy with and subsumes the classical (multi-type bosonic) Fock space representation of the Heisenberg-Weyl algebra.</p>
      <p>This shift of point of view, away from its canonical representation to the rule algebra itself, has unexpected consequences. We find that natural variants of the evaluation morphism map give rise to concepts of graph transformations hitherto not considered. These will be described in a separate paper [2]. In this extended abstract we limit ourselves to the simplest concept of double-pushout rewriting (DPO). We establish “jump-closure", i.e. that the sub-space of representations of formal graph observables is closed under the action of any rule set. It follows that for any rule set, one can derive a formal and self-consistent Kolmogorov backward equation for (representations of) formal observables.</p>
      <p>This result and the fallowing ones, co-authored by Vincent Danos, were published in peer-reviewed international conferences and journals. Although the papers are on HAL, they are not imported in the bibtex file so we can't cite them properly.
</p>
    </subsection>
    <subsection id="uid80" level="1">
      <bodyTitle>Giry and the machine</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Fredrik</firstname>
          <lastname>Dahlqvist</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>We present a general method – the Machine – to analyse and characterise in finitary terms natural transformations between well-known functors in the category Pol of Polish spaces. The method relies on a detailed analysis of the structure of Pol and a small set of categorical conditions on the domain and codomain functors. We apply the Machine to transformations from the Giry and positive measures functors to combinations of the Vietoris, multiset, Giry and positive measures functors. The multiset functor is shown to be defined in Pol and its properties established. We also show that for some combinations of these functors, there cannot exist more than one natural transformation between the functors, in particular the Giry monad has no natural transformations to itself apart from the identity. Finally we show how the Dirichlet and Poisson processes can be constructed with the Machine.
</p>
    </subsection>
    <subsection id="uid81" level="1">
      <bodyTitle>Robustly Parameterised Higher-Order Probabilistic Models</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Fredrik</firstname>
          <lastname>Dahlqvist</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>We present
a method for constructing robustly parameterised families of higher-order probabilistic models. Parameter spaces and models are represented by certain classes of functors in the category of Polish spaces. Maps from parameter spaces to models (parameterisations) are continuous and natural transformations between such functors. Naturality ensures that parameterised models are invariant by change of granularity – i.e. that parameterisations are intrinsic. Continuity ensures that models are robust with respect to their parameterisation. Our method allows one to build models from a set of basic functors among which the Giry probabilistic functor, spaces of cadlag trajectories (in continuous and discrete time), multisets and compact powersets. These functors can be combined by guarded composition, product and coproduct. Parameter spaces range over the polynomial closure of Giry-like functors. Thus we obtain a class of robust parameterised models which includes the Dirichlet process, various point processes (random sequences with values in Polish spaces) and other classical objects of probability theory. By extending techniques developed in prior work, we show how to reduce the questions of existence, uniqueness, naturality, and continuity of a parameterised model to combinatorial questions only involving finite spaces.
</p>
    </subsection>
    <subsection id="uid82" level="1">
      <bodyTitle>Bayesian inversion by ω-complete cone duality</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Fredrik</firstname>
          <lastname>Dahlqvist</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Ohad</firstname>
          <lastname>Kammar</lastname>
        </person>
      </participants>
      <p>The process of inverting Markov kernels relates to the important subject of Bayesian modelling and learning. In fact, Bayesian update is exactly kernel inversion. In this paper, we investigate how and when Markov kernels (aka stochastic relations, or probabilistic mappings, or simply kernels) can be inverted. We address the question both directly on the category of measurable spaces, and indirectly by interpreting kernels as Markov operators:
For the direct option, we introduce a typed version of the category of Markov kernels and use the so-called ‘disintegration of measures’. Here, one has to specialise to measurable spaces borne from a simple class of topological spaces -e.g. Polish spaces (other choices are possible). Our method and result greatly simplify a recent development in Ref. [4].
For the operator option, we use a cone version of the category of Markov operators (kernels seen as predicate transformers). That is to say, our linear operators are not just continuous, but are required to satisfy the stronger condition of being <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mi>ω</mi></math></formula>-chain-continuous.1 Prior work shows that one obtains an adjunction in the form of a pair of contravariant and inverse functors between the categories of L1- and <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><msup><mi>L</mi><mi>∞</mi></msup></math></formula>-cones [3]. Inversion, seen through the operator prism, is just adjunction.2 No topological assumption is needed.
We show that both categories (Markov kernels and ω-chain-continuous Markov operators) are related by a family of contravariant functors Tp for 1 ≤ p ≤ ∞. The Tp’s are Kleisli extensions of (duals of) conditional expectation functors introduced in Ref. [3].
With this bridge in place, we can prove that both notions of inversion agree when both defined: if f is a kernel, and f† its direct inverse, then T∞(f)† = T1(f†).
</p>
    </subsection>
    <subsection id="uid83" level="1">
      <bodyTitle>Continuous-time Markov chains as transformers of unbounded observables</bodyTitle>
      <participants>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Tobias</firstname>
          <lastname>Heindel</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Jakob</firstname>
          <lastname>Simonsen</lastname>
        </person>
      </participants>
      <p>We provide broad sufficient conditions for the com-putability of time-dependent averages of stochastic processes of the form f (Xt) where Xt is a continuous-time Markov chain (CTMC), and f is a real-valued function (aka an observable). We consider chains with values in a countable state space S, and possibly unbounded f s. Observables are seen as generalised predicates on S and chains are interpreted as transformers of such generalised predicates, mapping each observable f to a new observable Ptf defined as (Ptf)(x) = Ex(f (Xt)), which represents the mean value of f at time time t as a function of the initial state x. We obtain three results. First, the well-definedness of this operator interpretation is obtained for a large class of chains and observables by restricting Pt to judiciously chosen rescalings of the basic Banach space C0(S) of S-indexed sequences which vanish at infinity. We prove, under appropriate assumptions, that the restricted family Pt forms a strongly continuous operator semigroup (equivalently the time evolution map t → Pt is continuous w.r.t. the usual topology on bounded operators). The computability of the time evolution map follows by generic arguments of constructive analysis. A key point here is that the assumptions are flexible enough to accommodate unbounded observables, and we give explicit examples of such using stochastic Petri nets and stochastic string rewriting. Thirdly, we show that if the rate matrix (aka the q-matrix) of the CTMC is locally algebraic on a subspace containing f , the time evolution of projections t → (Ptf)(x) is PTIME computable for each x. These results provide a functional analytic alternative to Monte Carlo simulation as test bed for mean-field approximations, moment closure, and similar techniques that are fast, but lack absolute error guarantees.
</p>
    </subsection>
    <subsection id="uid84" level="1">
      <bodyTitle>Communities in socio-cognitive networks.</bodyTitle>
      <participants>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2016-idp153264">
          <firstname>Ricardo</firstname>
          <lastname>Honorato-Zimmer</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>We investigate a recent network model which combines social and cognitive features. Each node in the social network holds a (possibly different) cognitive network that represent its beliefs. In this internal cognitive network a node denotes a concept and a link indicates whether the two linked concepts are taken to be of a similar or opposite nature. We show how these networks naturally organise into communities and use this to develop a method that detects communities in social networks. How they organise depends on the social structure and the ratio between the cognitive and social forces driving the propagation of beliefs.
</p>
    </subsection>
    <subsection id="uid85" level="1">
      <bodyTitle>Synchronous Balanced Analysis</bodyTitle>
      <participants>
        <person key="antique-2016-idp143424">
          <firstname>Andreea</firstname>
          <lastname>Beica</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
      </participants>
      <p>When modeling Chemical Reaction Networks, a commonly used mathematical formalism is that of Petri Nets, with the usual interleaving execution semantics. We aim to substitute to a Chemical Reaction Network, especially a “growth” one (i.e., for which an exponential stationary phase exists), a piecewise synchronous approximation of the dynamics: a resource-allocation-centered Petri Net with maximal-step execution semantics. In the case of unimolecular chemical reactions, we prove the correctness of our method and show that it can be used either as an approximation of the dynamics, or as a method of constraining the reaction rate constants (an alternative to flux balance analysis, using an emergent formally defined notion of “growth rate” as the objective function), or a technique of refuting models.
</p>
    </subsection>
    <subsection id="uid86" level="1">
      <bodyTitle>Pointless learning</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Florence</firstname>
          <lastname>Clerc</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Fredrik</firstname>
          <lastname>Dahlqvist</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
      </participants>
      <p>Bayesian inversion is at the heart of probabilistic programming and more generally machine learning. Understanding inversion is made difficult by the pointful (kernel-centric) point of view usually taken in the literature. We develop in a pointless (kernel-free) approach to inver- sion. While doing so, we revisit some foundational objects of probability theory, unravel their category-theoretical underpinnings and show how pointless Bayesian inversion sits naturally at the centre of this construction.
</p>
    </subsection>
    <subsection id="uid87" level="1">
      <bodyTitle>Survival of the fattest.</bodyTitle>
      <participants>
        <person key="antique-2016-idp143424">
          <firstname>Andreea</firstname>
          <lastname>Beica</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Guillaume</firstname>
          <lastname>Terradot</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Andrea</firstname>
          <lastname>Weisse</lastname>
        </person>
      </participants>
      <p>Cells derive resources from their environments and use them to fuel the
biosynthetic processes that determine cell growth. Depending on how
responsive the biosynthetic processes are to the availability of
intracellular resources, cells can build up different levels of resource
storage. Here we use a recent mathematical model of the coarse-grained
mechanisms that drive cellular growth to investigate the effects of
cellular resource storage on growth. We show that, on the one hand, there
is a cost associated with high levels of storage resulting from the loss
of stored resources due to dilution. We further show that, on the other
hand, high levels of storage can benefit cells in variable environments by
increasing biomass production during transitions from one medium to
another. Our results thus suggest that cells may face trade-offs in their
maintenance of resource storage based on the frequency of environmental
change.
</p>
    </subsection>
    <subsection id="uid88" level="1">
      <bodyTitle>The algebras of graph rewriting</bodyTitle>
      <participants>
        <person key="antique-2016-idp150784">
          <firstname>Nicolas</firstname>
          <lastname>Behr</lastname>
        </person>
        <person key="antique-2014-idp65608">
          <firstname>Vincent</firstname>
          <lastname>Danos</lastname>
        </person>
        <person key="antique-2015-idp81536">
          <firstname>Ilias</firstname>
          <lastname>Garnier</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Tobias</firstname>
          <lastname>Heindel</lastname>
        </person>
      </participants>
      <p>The concept of diagrammatic combinatorial Hopf algebras in the form introduced for describing the Heisenberg-Weyl algebra is extended to the case of so-called rule diagrams that present graph rewriting rules and their composites. The resulting rule diagram algebra may then be suitably restricted in four different ways to what we call the rule algebras, which are non-commutative, unital associative algebras that implement the algebra of compositions of graph rewriting rules. Notably, our framework reveals that there exist two more types of graph rewriting systems than previously known in the literature, and we present an analysis of the structure of the rule algebras as well as a form of Poincaré-Birkhoff-Witt theorem for the rule diagram algebra. Our work lays the foundation for a fundamentally new way of analyzing graph transformation systems, and embeds this very important concept from theoretical computer science firmly into the realm of mathematical combinatorics and statistical physics.
</p>
    </subsection>
    <subsection id="uid89" level="1">
      <bodyTitle>PSYNC: A partially synchronous language for fault-tolerant distributed algorithms</bodyTitle>
      <participants>
        <person key="PASUSERID">
          <firstname>Cezara</firstname>
          <lastname>Drăgoi</lastname>
          <moreinfo>correspondant</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Thomas</firstname>
          <lastname>Henzinger</lastname>
          <moreinfo>IST Austria, Austria</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Damien</firstname>
          <lastname>Zufferey</lastname>
          <moreinfo>MIT, CSAIL, USA</moreinfo>
        </person>
      </participants>
      <p>Fault-tolerant distributed systems,
Programming languages,
Verification

Fault-tolerant distributed algorithms play an important role in many critical/high-availability applications. These algorithms are notori- ously difficult to implement correctly, due to asynchronous com- munication and the occurrence of faults, such as the network drop- ping messages or computers crashing.
We introduce PSYNC in <ref xlink:href="#antique-2016-bid7" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, a domain specific language based on the Heard-Of model, which views asynchronous faulty systems as syn- chronous ones with an adversarial environment that simulates asyn- chrony and faults by dropping messages. We define a runtime sys- tem for PSYNC that efficiently executes on asynchronous networks. We formalize the relation between the runtime system and PSYNC in terms of observational refinement. The high-level lockstep ab- straction introduced by PSYNC simplifies the design and imple- mentation of fault-tolerant distributed algorithms and enables auto- mated formal verification.
We have implemented an embedding of PSYNC in the SCALA programming language with a runtime system for asynchronous networks. We show the applicability of PSYNC by implementing several important fault-tolerant distributed algorithms and we com- pare the implementation of consensus algorithms in PSYNC against implementations in other languages in terms of code size, runtime efficiency, and verification.
</p>
    </subsection>
  </resultats>
  <partenariat id="uid90">
    <bodyTitle>Partnerships and Cooperations</bodyTitle>
    <subsection id="uid91" level="1">
      <bodyTitle>National Initiatives</bodyTitle>
      <subsection id="uid92" level="2">
        <bodyTitle>
          <ref xlink:href="http://www.di.ens.fr/~feret/anastasec/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
            <span class="smallcap" align="left">AnaStaSec</span>
          </ref>
        </bodyTitle>
        <sanspuceslist>
          <li id="uid93">
            <p noindent="true">Title: Static Analysis for Security Properties</p>
          </li>
          <li id="uid94">
            <p noindent="true">Type: ANR générique 2014</p>
          </li>
          <li id="uid95">
            <p noindent="true">Defi: Société de l'information et de la communication</p>
          </li>
          <li id="uid96">
            <p noindent="true">Instrument: ANR grant</p>
          </li>
          <li id="uid97">
            <p noindent="true">Duration: January 2015 - December 2018</p>
          </li>
          <li id="uid98">
            <p noindent="true">Coordinator: Inria Paris-Rocquencourt (France)</p>
          </li>
          <li id="uid99">
            <p noindent="true">Others partners: Airbus France (France), AMOSSYS (France),
CEA LIST (France), Inria Rennes-Bretagne Atlantique (France),
TrustInSoft (France)</p>
          </li>
          <li id="uid100">
            <p noindent="true">Inria contact: Jérôme Feret</p>
          </li>
          <li id="uid101">
            <p noindent="true">See also: <ref xlink:href="http://www.di.ens.fr/~feret/anastasec/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.di.ens.fr/ feret/anastasec/</ref></p>
          </li>
          <li id="uid102">
            <p noindent="true">Abstract:
An emerging structure in our information processing-based society
is the notion of trusted complex systems interacting via heterogeneous
networks with an open, mostly untrusted world. This view characterises
a wide variety of systems ranging from the information system of a
company to the connected components of a private house, all of which
have to be connected with the outside.</p>
            <p>It is in particular the case for some aircraft-embedded computer
systems, which communicate with the ground through untrusted
communication media. Besides, the increasing demand for new
capabilities, such as enhanced on-board connectivity, e.g. using
mobile devices, together with the need for cost reduction, leads to
more integrated and interconnected systems. For instance, modern
aircrafts embed a large number of computer systems, from
safety-critical cockpit avionics to passenger entertainment. Some
systems meet both safety and security requirements. Despite thorough
segregation of subsystems and networks, some shared communication
resources raise the concern of possible intrusions.</p>
            <p>Some techniques have been developed and still need to be investigated
to ensure security and confidentiality properties of such
systems. Moreover, most of them are model-based techniques operating
only at architectural level and provide no guarantee on the actual
implementations. However, most security incidents are due to attackers
exploiting subtle implementation-level software
vulnerabilities. Systems should therefore be analyzed at software
level as well (i.e. source or executable code), in order to provide
formal assurance that security properties indeed hold for real
systems.</p>
            <p>Because of the size of such systems, and considering that they are
evolving entities, the only economically viable alternative is to
perform automatic analyses. Such analyses of security and
confidentiality properties have never been achieved on large-scale
systems where security properties interact with other software
properties, and even the mapping between high-level models of the
systems and the large software base implementing them has never been
done and represents a great challenge. The goal of this project is to
develop the new concepts and technologies necessary to meet such a
challenge.</p>
            <p>The project <ref xlink:href="http://www.di.ens.fr/~feret/anastasec/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">AnaStaSec</span></ref> project will allow for the formal verification
of security properties of software-intensive embedded systems, using
automatic static analysis techniques at different levels of
representation: models, source and binary codes. Among expected
outcomes of the project will be a set of prototype tools, able to deal
with realistic large systems and the elaboration of industrial
security evaluation processes, based on static analysis.</p>
          </li>
        </sanspuceslist>
      </subsection>
      <subsection id="uid103" level="2">
        <bodyTitle>​REPAS</bodyTitle>
        <p>The project REPAS, Reliable and Privacy-Aware Software Systems via Bisimulation Metrics (coordination Catuscia Palamidessi, Inria Saclay), aims at investigating quantitative notions and tools for proving program correctness and protecting privacy, focusing on bisimulation metrics, the natural extension of bisimulation on quantitative systems. A key application is to develop mechanisms to protect the privacy of users when their location traces are collected. Partners: Inria (Comete, Focus), ENS Cachan, ENS Lyon, University of Bologna.</p>
      </subsection>
      <subsection id="uid104" level="2">
        <bodyTitle>
          <ref xlink:href="http://compcert.inria.fr/verasco/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
            <span class="smallcap" align="left">VerAsCo</span>
          </ref>
        </bodyTitle>
        <sanspuceslist>
          <li id="uid105">
            <p noindent="true">Title: Formally-verified static analyzers and compilers</p>
          </li>
          <li id="uid106">
            <p noindent="true">Type: ANR Ingénierie Numérique Sécurité 2011</p>
          </li>
          <li id="uid107">
            <p noindent="true">Instrument: ANR grant</p>
          </li>
          <li id="uid108">
            <p noindent="true">Duration: September 2011 - June 2016</p>
          </li>
          <li id="uid109">
            <p noindent="true">Coordinator: Inria (France)</p>
          </li>
          <li id="uid110">
            <p noindent="true">Others partners: Airbus France (France), IRISA (France), Inria
Saclay (France)</p>
          </li>
          <li id="uid111">
            <p noindent="true">See also: <ref xlink:href="http://www.systematic-paris-region.org/fr/projets/verasco" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.systematic-paris-region.org/fr/projets/verasco</ref></p>
          </li>
          <li id="uid112">
            <p noindent="true">Abstract: The usefulness of verification tools in the
development and certification of critical software is limited by the
amount of trust one can have in their results. A first potential
issue is <i>unsoundness</i> of a verification tool: if a verification
tool fails (by mistake or by design) to account for all possible
executions of the program under verification, it can conclude that the
program is correct while it actually misbehaves when executed. A
second, more insidious, issue is <i>miscompilation</i>: verification
tools generally operate at the level of source code or executable
model; a bug in the compilers and code generators that produce the
executable code that actually runs can lead to a wrong executable
being generated from a correct program.</p>
            <p>The project <ref xlink:href="http://compcert.inria.fr/verasco/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">VerAsCo</span></ref>advocates a mathematically-grounded solution
to the issues of formal verifying compilers and verification tools.
We set out to develop a generic static analyzer based on abstract
interpretation for the C language, along with a number of advanced
abstract domains and domain combination operators, and prove the
soundness of this analyzer using the Coq proof assistant. Likewise,
we will continue our work on the CompCert C formally-verified
compiler, the first realistic C compiler that has been mechanically
proved to be free of any miscompilation will be continued. Finally,
the tool qualification issues that must be addressed before
formally-verified tools can be used in the aircraft industry, will be
investigated.</p>
          </li>
        </sanspuceslist>
      </subsection>
      <subsection id="uid113" level="2">
        <bodyTitle>
          <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
            <span class="smallcap" align="left">AstréeA</span>
          </ref>
        </bodyTitle>
        <sanspuceslist>
          <li id="uid114">
            <p noindent="true">Title: Static Analysis of Embedded Asynchronous Real-Time
Software</p>
          </li>
          <li id="uid115">
            <p noindent="true">Type: ANR Ingénierie Numérique Sécurité 2011</p>
          </li>
          <li id="uid116">
            <p noindent="true">Instrument: ANR grant</p>
          </li>
          <li id="uid117">
            <p noindent="true">Duration: January 2012 - November 2016</p>
          </li>
          <li id="uid118">
            <p noindent="true">Coordinator: Airbus France (France)</p>
          </li>
          <li id="uid119">
            <p noindent="true">Others partners: École normale supérieure (France)</p>
          </li>
          <li id="uid120">
            <p noindent="true">Inria contact: Antoine Miné</p>
          </li>
          <li id="uid121">
            <p noindent="true">See also:
<ref xlink:href="http://www.astreea.ens.fr" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.astreea.ens.fr</ref></p>
          </li>
          <li id="uid122">
            <p noindent="true">Abstract: The focus of the <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">AstréeA</span></ref> project is on the
development of static analysis by abstract interpretation to check the
safety of large-scale asynchronous embedded software. During the
<span class="smallcap" align="left">Thesee</span> ANR project (2006–2010), we developed a concrete and
abstract models of the ARINC 653 operating system and its scheduler,
and a first analyzer prototype. The gist of the <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">AstréeA</span></ref> project is
the continuation of this effort, following the recipe that made the
success of <ref xlink:href="http://www.astree.ens.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><span class="smallcap" align="left">Astrée</span></ref>: an incremental refinement of the analyzer until
reaching the zero false alarm goal. The refinement concerns: the
abstraction of process interactions (relational and history-sensitive
abstractions), the scheduler model (supporting more synchronisation
primitives and taking priorities into account), the memory model
(supporting volatile variables), and the abstraction of dynamical
data-structures (linked lists). Patrick Cousot is the principal
investigator for this project.</p>
          </li>
        </sanspuceslist>
      </subsection>
      <subsection id="uid123" level="2">
        <bodyTitle>VeriFault</bodyTitle>
        <p>This was a PEPS project for one year, coordinated by Cezara Drăgoi, on the topic of fault-tolerant distributed algorithms.
These algorithms are notoriously difficult to implement correctly, due to asynchronous communication and the occurrence of faults, such as the network dropping messages or computers crashing. Although fault-tolerant algorithms are at the core of critical applications, there are no automated verification techniques that can deal with their complexity.
Due to the complexity distributed systems have reached, we believe it is no longer realistic nor efficient to assume that high level specifications can be proved when development and verification are two disconnected steps in the software production process. Therefore we propose to introduce a domain specific language that has a high-level control structure which focuses on the algorithmic aspects rather than on low-level network and timer code, and makes programs amendable to automated verification.
</p>
      </subsection>
    </subsection>
    <subsection id="uid124" level="1">
      <bodyTitle>European Initiatives</bodyTitle>
      <subsection id="uid125" level="2">
        <bodyTitle>FP7 <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mo>&amp;</mo></math></formula> H2020 Projects</bodyTitle>
        <p>ASSUME, ITEA 3 project (Affordable Safe <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mo>&amp;</mo></math></formula> Secure Mobility Evolution).
Affordable Safe <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mo>&amp;</mo></math></formula> Secure Mobility Evolution</p>
        <p>Future mobility solutions will increasingly rely on smart components that continuously monitor the environment and assume more and more responsibility for a convenient, safe and reliable operation. Currently the single most important roadblock for this market is the ability to come up with an affordable, safe multi-core development methodology that allows industry to deliver trustworthy new functions at competitive prices. ASSUME will provide a seamless engineering methodology, which addresses this roadblock on the constructive and analytic side.</p>
      </subsection>
    </subsection>
    <subsection id="uid126" level="1">
      <bodyTitle>International Research Visitors</bodyTitle>
      <subsection id="uid127" level="2">
        <bodyTitle>Visits of International Scientists</bodyTitle>
        <p>Prof. Kwangkeun Yi Visiteur from Seoul National University, was an invited visitor until Oct 2016.</p>
        <subsection id="uid128" level="3">
          <bodyTitle>Internships</bodyTitle>
          <simplelist>
            <li id="uid129">
              <p noindent="true">Ken Chanseau Saint-Germain, ENS Paris, until Aug 2016</p>
            </li>
            <li id="uid130">
              <p noindent="true">Marc Chevalier, ENS Lyon, since Sept 2016</p>
            </li>
            <li id="uid131">
              <p noindent="true">Anton Kulaga, Jul and Aug 2016</p>
            </li>
            <li id="uid132">
              <p noindent="true">Yoon Seok Ko, Inria, until Jun 2016</p>
            </li>
            <li id="uid133">
              <p noindent="true">David Romero Suarez, Inria, from Feb 2016 until May 2016]</p>
            </li>
            <li id="uid134">
              <p noindent="true">Gaelle Candel, Chimie ParisTech</p>
            </li>
          </simplelist>
        </subsection>
      </subsection>
    </subsection>
  </partenariat>
  <diffusion id="uid135">
    <bodyTitle>Dissemination</bodyTitle>
    <subsection id="uid136" level="1">
      <bodyTitle>Promoting Scientific Activities</bodyTitle>
      <subsection id="uid137" level="2">
        <bodyTitle>Scientific Events Organisation</bodyTitle>
        <subsection id="uid138" level="3">
          <bodyTitle>General Chair, Scientific Chair</bodyTitle>
          <p>Jérôme Feret is a member of the editorial board of the Frontiers in Genetics journal and the Open Journal of Modeling and Simulation.</p>
        </subsection>
        <subsection id="uid139" level="3">
          <bodyTitle>Member of the Organizing Committees</bodyTitle>
          <p>Jérôme Feret organized the 40th of Abstract Interpretation at POPL2017 January 21, 2017, Paris, France (co-organizer).</p>
        </subsection>
      </subsection>
      <subsection id="uid140" level="2">
        <bodyTitle>Scientific Events Selection</bodyTitle>
        <subsection id="uid141" level="3">
          <bodyTitle>Chair of Conference Program Committees</bodyTitle>
          <p>Xavier Rival was chair of Static Analysis Symposium SAS 2016, Edinburgh.</p>
          <p>Jérôme Feret co-chaired the fifteenth Conference on Computational Methods in Systems Biology - CMSB 2017, September 27–29, 2017, Darmstadt, Germany.</p>
        </subsection>
        <subsection id="uid142" level="3">
          <bodyTitle>Member of the Conference Program Committees</bodyTitle>
          <p>Vincent Danos served on the PC of Computational Methods in Systems Biology, CMSB'16, Cambridge and Complexis'17.</p>
          <p>Xavier Rival served on the PC of the 26th European Symposium on Programming (ESOP 2017).</p>
          <p>Cezara Drăgoi served on the PC of</p>
          <simplelist>
            <li id="uid143">
              <p noindent="true">28th International Conference on Computer-Aided Verification (ERC), CAV 2016,</p>
            </li>
            <li id="uid144">
              <p noindent="true">37th INTERNATIONAL CONFERENCE ON APPLICATIONS AND THEORY OF PETRI NETS AND CONCURRENCY, ACSD 2016,</p>
            </li>
            <li id="uid145">
              <p noindent="true">23rd International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2017,</p>
            </li>
            <li id="uid146">
              <p noindent="true">18th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI 2017,</p>
            </li>
            <li id="uid147">
              <p noindent="true">ACM SIGPLAN Symposium on Programming Language Design &amp; Implementation, PLDI 2017.</p>
            </li>
          </simplelist>
          <p>Jérôme Feret served on the PC of</p>
          <simplelist>
            <li id="uid148">
              <p noindent="true">the 8th International Conference on Bioinformatics, Biocomputational Systems and Biotechnologies - BIOTECHNO 2016,</p>
            </li>
            <li id="uid149">
              <p noindent="true">the 26th International Symposium on Logic-Based Program Synthesis and transformation - LOPSTR 2016,</p>
            </li>
            <li id="uid150">
              <p noindent="true">the 23rd Static Analysis Symposium
Sept 8-10 2016, Edinburgh,</p>
            </li>
            <li id="uid151">
              <p noindent="true">7th International Workshop on Static Analysis and Systems Biology - SASB 2016,</p>
            </li>
            <li id="uid152">
              <p noindent="true">14th International Conference on Computational Methods in Systems Biology - CMSB 2016
Sept 21-23 2016, Cambridge, UK,</p>
            </li>
            <li id="uid153">
              <p noindent="true">Fourth International Conference on Tools and Methods for Program Analysis - TMPA 2017
March 3–4, 2017, Moscow, Russia, JOBIM 2017
July 2-6 2017, Lille, France.</p>
            </li>
          </simplelist>
        </subsection>
        <subsection id="uid154" level="3">
          <bodyTitle>Reviewer</bodyTitle>
          <p>Vincent Danos was a reviewer for the 19th International Conference on Foundations of Software Science and Computation Structures (FoSSaCS) 2017, the ​26th European Symposium on Programming (ESOP 2017) 2017, LMCS, MSCS​.</p>
          <p>Cezara Drăgoi was a reviewer for 19th International Conference on Foundations of Software Science and Computation Structures (FoSSaCS) 2017, the 27th International Conference on Concurrency Theory CONCUR 2016, and ​the 26th European Symposium on Programming (ESOP 2017) 2017.</p>
          <p>Xavier Rival was a reviewer for 23rd International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2017 and ACM SIGPLAN Symposium on Programming Language Design &amp; Implementation, PLDI 2017.</p>
          <p>Jérôme Feret was a reviewer for the 17th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI 2016, the 27th International Conference on Concurrency Theory CONCUR 2016, the 43rd International Colloquium on Automata, Languages and Programming 2016, the 31st ACM/IEEE Symposium on
Logic in Computer Science, LICS 2016.</p>
        </subsection>
      </subsection>
      <subsection id="uid155" level="2">
        <bodyTitle>Journal</bodyTitle>
        <subsection id="uid156" level="3">
          <bodyTitle>Member of the Editorial Boards</bodyTitle>
          <p>Jérôme Feret is a member of the editorial board of the Frontiers in Genetics journal and the Open Journal of Modeling and Simulation .</p>
        </subsection>
        <subsection id="uid157" level="3">
          <bodyTitle>Reviewer - Reviewing Activities</bodyTitle>
          <p>Xavier Rival was a reviewer for ACM Transactions on Programming Languages and Systems TOPLAS.</p>
          <p>Jerome Feret was a reviewer for Theoretical Computer Science 2016.</p>
        </subsection>
      </subsection>
      <subsection id="uid158" level="2">
        <bodyTitle>Invited Talks</bodyTitle>
        <p>Jérôme Feret gave “An overview of the Astrée/AstréeA analyzer.
" at Journées scientifiques Inria Rennes, 20-22 june 2016 and at the
workshop « Verified Trustworthy Software Systems »
Imperial College, 6-7 April 2016.</p>
        <p>Vincent Danos talked about `Residence: Simons Institute Program Logical Structures and Computations" at CONCUR 2016, Quebec, Aug 25-2 and at Berkeley, Aug 17-Dec 16. He also gave invited talks at SysMod SIG 2016, ISMB, Orlando, Jul 9, Xenobiology 2, XB2, May 24-26, Berlin, IPM Formal Methods Day, Teheran, Jan 10.</p>
      </subsection>
    </subsection>
    <subsection id="uid159" level="1">
      <bodyTitle>Teaching - Supervision - Juries</bodyTitle>
      <subsection id="uid160" level="2">
        <bodyTitle>Teaching</bodyTitle>
        <sanspuceslist>
          <li id="uid161">
            <p noindent="true">Licence :</p>
            <simplelist>
              <li id="uid162">
                <p noindent="true">Xavier Rival, “Semantics and Application to Verification",20h, Undergraduate course (L3), at Ecole Normale
Supérieure</p>
              </li>
              <li id="uid163">
                <p noindent="true">Xavier Rival, “Introduction to Static Analysis", 8h, Course at Ecole des Mines de Paris, L3</p>
              </li>
              <li id="uid164">
                <p noindent="true">Cezara Drăgoi, “Programation concurrente et distribuée", Ecole Politechnique, L2</p>
              </li>
              <li id="uid165">
                <p noindent="true">Cezara Drăgoi, “Les principes des langages de programmation", Ecole Politechnique, L1</p>
              </li>
              <li id="uid166">
                <p noindent="true">Jérôme Feret, and Cezara Drăgoi, Mathematics, 40h, L1, FDV Bachelor program (Frontiers in Life Sciences (FdV)), Université Paris-Descartes, France.</p>
              </li>
            </simplelist>
          </li>
          <li id="uid167">
            <p noindent="true">Master :</p>
            <simplelist>
              <li id="uid168">
                <p noindent="true">Vincent, Disruptive technologies
and public policies, MSc Public affairs, Sciences Po, France.</p>
              </li>
              <li id="uid169">
                <p noindent="true">Xavier Rival, Protocol Safety and Verification, Master Course (M2) in the Advanced Communication Networks Master (12h hours), at
Polytechnique and Ecole Nationale Supérieure des Telecoms</p>
              </li>
              <li id="uid170">
                <p noindent="true">Xavier Rival, “Verification" Lab Course at Ecole Polytechnique (M1, 20h)</p>
              </li>
              <li id="uid171">
                <p noindent="true">Vindent Danos and Jérôme Feret (with Jean Krivine), Computational Biology, 24h, M1. Interdisciplinary Approaches to Life Science (AIV), Master Program, Université Paris-Descartes, France.</p>
              </li>
              <li id="uid172">
                <p noindent="true">Cezara Drăgoi, Jérôme Feret, Antoine Miné, and Xavier Rival, Abstract Interpretation: application to verification and static analysis, 72h ETD, M2. Parisian Master of Research in Computer Science (MPRI). École normale supérieure. France.</p>
              </li>
            </simplelist>
          </li>
          <li id="uid173">
            <p noindent="true">Doctorat :
Jérôme Feret, “Interprétation abstraite de modèles de voies de signalisation intracellulaire ", Lectures (3 hours) in the summer school “Modélisation Formelle de Réseaux de Régulation Biologique”, Porquerolles, June 2016 France.</p>
          </li>
        </sanspuceslist>
      </subsection>
      <subsection id="uid174" level="2">
        <bodyTitle>Juries</bodyTitle>
        <p>Jérôme Feret was a member of the recruitment committee for an assistant professor in Paris-Diderot University 2016.</p>
        <p>Vincent Danos was examiner​ and reviewer​ for the ​HDR of ​Sylvain Soliman (Ecole Polytechnique, 7th of December 2016).</p>
      </subsection>
    </subsection>
  </diffusion>
  <biblio id="bibliography" html="bibliography" numero="10" titre="Bibliography">
    
    <biblStruct id="antique-2016-bid12" type="proceedings" rend="year" n="cite:rival:hal-01388205">
      <identifiant type="doi" value="10.1007/978-3-662-53413-7"/>
      <identifiant type="hal" value="hal-01388205"/>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes">
        <title level="m">Static Analysis: 23rd International Symposium, (SAS 2016), Edinburgh, UK, September 8-10, 2016, Proceedings</title>
        <editor role="editor">
          <persName key="antique-2014-idm29376">
            <foreName>Xavier</foreName>
            <surname>Rival</surname>
            <initial>X.</initial>
          </persName>
        </editor>
        <imprint>
          <biblScope type="volume">LNCS</biblScope>
          <biblScope type="number">9837</biblScope>
          <publisher>
            <orgName>Springer<address><addrLine>Edinburgh, United Kingdom</addrLine></address></orgName>
          </publisher>
          <dateStruct>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01388205" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01388205</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid11" type="proceedings" rend="year" n="cite:zhang:hal-01388271">
      <identifiant type="doi" value="10.1145/2931021"/>
      <identifiant type="hal" value="hal-01388271"/>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes">
        <title level="m">State Of the Art in Program Analysis: International Workshop, (SOAP 2016), SOAP@PLDI 2016, Santa Barbara, CA, USA, June 14, 2016Proceedings of the 5th ACM SIGPLAN </title>
        <editor role="editor">
          <persName>
            <foreName>Charles</foreName>
            <surname>Zhang</surname>
            <initial>C.</initial>
          </persName>
          <persName key="antique-2014-idm29376">
            <foreName>Xavier</foreName>
            <surname>Rival</surname>
            <initial>X.</initial>
          </persName>
        </editor>
        <imprint>
          <publisher>
            <orgName>ACM<address><addrLine>Santa Barbara, United States</addrLine></address></orgName>
          </publisher>
          <dateStruct>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01388271" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01388271</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid5" type="article" rend="year" n="cite:aboujaoude:hal-01379733">
      <identifiant type="doi" value="10.1016/j.biosystems.2016.09.001"/>
      <identifiant type="hal" value="hal-01379733"/>
      <analytic>
        <title level="a">Formal Derivation of Qualitative Dynamical Models from Biochemical Networks</title>
        <author>
          <persName>
            <foreName>Wassim</foreName>
            <surname>Abou-Jaoudé</surname>
            <initial>W.</initial>
          </persName>
          <persName key="lifeware-2014-idp71960">
            <foreName>Denis</foreName>
            <surname>Thieffry</surname>
            <initial>D.</initial>
          </persName>
          <persName key="antique-2014-idp67080">
            <foreName>Jérôme</foreName>
            <surname>Feret</surname>
            <initial>J.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid00257">
        <idno type="issn">0303-2647</idno>
        <title level="j">BioSystems</title>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">100</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01379733" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01379733</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid2" type="article" rend="year" n="cite:liu:hal-01399837">
      <identifiant type="doi" value="10.1016/j.cl.2016.01.005"/>
      <identifiant type="hal" value="hal-01399837"/>
      <analytic>
        <title level="a">An array content static analysis based on non-contiguous partitions</title>
        <author>
          <persName key="antique-2016-idp136160">
            <foreName>Jiangchao</foreName>
            <surname>Liu</surname>
            <initial>J.</initial>
          </persName>
          <persName key="antique-2014-idm29376">
            <foreName>Xavier</foreName>
            <surname>Rival</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid00394">
        <idno type="issn">1477-8424</idno>
        <title level="j">Computer Languages, Systems and Structures</title>
        <imprint>
          <biblScope type="volume">47</biblScope>
          <biblScope type="number">1</biblScope>
          <dateStruct>
            <year>2017</year>
          </dateStruct>
          <biblScope type="pages">104–129</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01399837" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01399837</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid9" type="article" rend="year" n="cite:ouadjaout:hal-01350646">
      <identifiant type="doi" value="10.1016/j.jss.2016.07.030"/>
      <identifiant type="hal" value="hal-01350646"/>
      <analytic>
        <title level="a">Static analysis by abstract interpretation of functional properties of device drivers in TinyOS</title>
        <author>
          <persName key="antique-2014-idp89144">
            <foreName>Abdelraouf</foreName>
            <surname>Ouadjaout</surname>
            <initial>A.</initial>
          </persName>
          <persName key="antique-2014-idp68336">
            <foreName>Antoine</foreName>
            <surname>Miné</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Noureddine</foreName>
            <surname>Lasla</surname>
            <initial>N.</initial>
          </persName>
          <persName>
            <foreName>Nadjib</foreName>
            <surname>Badache</surname>
            <initial>N.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid01278">
        <idno type="issn">0164-1212</idno>
        <title level="j">Journal of Systems and Software</title>
        <imprint>
          <biblScope type="volume">120</biblScope>
          <dateStruct>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">114–132</biblScope>
          <ref xlink:href="http://hal.upmc.fr/hal-01350646" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01350646</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid10" type="inproceedings" rend="year" n="cite:drgoi:hal-01251199">
      <identifiant type="doi" value="10.1145/nnnnnnn.nnnnnnn"/>
      <identifiant type="hal" value="hal-01251199"/>
      <analytic>
        <title level="a">PSYNC: A partially synchronous language for fault-tolerant distributed algorithms</title>
        <author>
          <persName key="antique-2015-idp65272">
            <foreName>Cezara</foreName>
            <surname>Drăgoi</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Thomas</foreName>
            <surname>Henzinger</surname>
            <initial>T.</initial>
          </persName>
          <persName>
            <foreName>Damien</foreName>
            <surname>Zufferey</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Proceedings of the 43nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
        <loc>Saint Petersburg, Florida, United States</loc>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01251199" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01251199</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>43</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid7" type="inproceedings" rend="year" n="cite:drgoi:hal-01434325">
      <identifiant type="doi" value="10.1145/nnnnnnn.nnnnnnn"/>
      <identifiant type="hal" value="hal-01434325"/>
      <analytic>
        <title level="a">PSYNC: A Partially Synchronous Language for Fault-Tolerant Distributed Algorithms</title>
        <author>
          <persName key="antique-2015-idp65272">
            <foreName>Cezara</foreName>
            <surname>Drăgoi</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Thomas</foreName>
            <surname>Henzinger</surname>
            <initial>T.</initial>
          </persName>
          <persName>
            <foreName>Damien</foreName>
            <surname>Zufferey</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">POPL</title>
        <loc>Saint Petersburg , United States</loc>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2017</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01434325" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01434325</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>37</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid4" type="inproceedings" rend="year" n="cite:feret:hal-01379897">
      <identifiant type="doi" value="10.1007/978-3-319-45177-0_8"/>
      <identifiant type="hal" value="hal-01379897"/>
      <analytic>
        <title level="a">Local traces: an over-approximation of the behaviour of the proteins in rule-based models</title>
        <author>
          <persName key="antique-2014-idp67080">
            <foreName>Jérôme</foreName>
            <surname>Feret</surname>
            <initial>J.</initial>
          </persName>
          <persName key="deducteam-2014-idp112264">
            <foreName>Kim Quyen</foreName>
            <surname>Ly</surname>
            <initial>K. Q.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <editor role="editor">
          <persName>
            <foreName>E.</foreName>
            <surname>Bartocci</surname>
            <initial>E.</initial>
          </persName>
          <persName>
            <foreName>P.</foreName>
            <surname>Lio'</surname>
            <initial>P.</initial>
          </persName>
          <persName>
            <foreName>N.</foreName>
            <surname>Paoletti</surname>
            <initial>N.</initial>
          </persName>
        </editor>
        <title level="m">CMSB 2016 - Fourteenth Conference on Computational Method in Systems Biology</title>
        <loc>Cambridge, United Kingdom</loc>
        <title level="s">Computational Methods in Systems Biology</title>
        <imprint>
          <biblScope type="volume">9859</biblScope>
          <publisher>
            <orgName>Springer</orgName>
          </publisher>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">116-131</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01379897" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01379897</ref>
        </imprint>
        <meeting id="cid115706">
          <title>International Conference on Computational Methods in Systems Biology</title>
          <num>14</num>
          <abbr type="sigle">CMSB</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid3" type="inproceedings" rend="year" n="cite:feret:hal-01379902">
      <identifiant type="hal" value="hal-01379902"/>
      <analytic>
        <title level="a">Reachability analysis via orthogonal sets of patterns</title>
        <author>
          <persName key="antique-2014-idp67080">
            <foreName>Jérôme</foreName>
            <surname>Feret</surname>
            <initial>J.</initial>
          </persName>
          <persName key="deducteam-2014-idp112264">
            <foreName>Kim Quyen</foreName>
            <surname>Ly</surname>
            <initial>K. Q.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <editor role="editor">
          <persName>
            <foreName>David</foreName>
            <surname>Safranek</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Guido</foreName>
            <surname>Sanguinetti</surname>
            <initial>G.</initial>
          </persName>
        </editor>
        <title level="m">7th International Workshop on Static Analysis and Systems Biology, (SASB 2016)</title>
        <loc>Edinburgh, United Kingdom</loc>
        <title level="s">Static Analysis and Systems Biology</title>
        <imprint>
          <publisher>
            <orgName>Elsevier</orgName>
          </publisher>
          <publisher>
            <orgName type="organisation">David Safranek and Guido Sanguinetti</orgName>
          </publisher>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01379902" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01379902</ref>
        </imprint>
        <meeting id="cid623740">
          <title>International Workshop on Static Analysis and Systems Biology</title>
          <num>7</num>
          <abbr type="sigle">SASB</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid6" type="inproceedings" rend="year" n="cite:mine:hal-01271552">
      <identifiant type="hal" value="hal-01271552"/>
      <analytic>
        <title level="a">Taking Static Analysis to the Next Level: Proving the Absence of Run-Time Errors and Data Races with Astrée</title>
        <author>
          <persName key="antique-2014-idp68336">
            <foreName>Antoine</foreName>
            <surname>Miné</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Laurent</foreName>
            <surname>Mauborgne</surname>
            <initial>L.</initial>
          </persName>
          <persName key="antique-2014-idm29376">
            <foreName>Xavier</foreName>
            <surname>Rival</surname>
            <initial>X.</initial>
          </persName>
          <persName key="antique-2014-idp67080">
            <foreName>Jerome</foreName>
            <surname>Feret</surname>
            <initial>J.</initial>
          </persName>
          <persName key="antique-2014-idm27896">
            <foreName>Patrick</foreName>
            <surname>Cousot</surname>
            <initial>P.</initial>
          </persName>
          <persName>
            <foreName>Daniel</foreName>
            <surname>Kästner</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Stephan</foreName>
            <surname>Wilhelm</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Christian</foreName>
            <surname>Ferdinand</surname>
            <initial>C.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">8th European Congress on Embedded Real Time Software and Systems (ERTS 2016)</title>
        <loc>Toulouse, France</loc>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.archives-ouvertes.fr/hal-01271552" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>archives-ouvertes.<allowbreak/>fr/<allowbreak/>hal-01271552</ref>
        </imprint>
        <meeting id="cid68744">
          <title>European Congress on Embedded Real Time Software</title>
          <num>8</num>
          <abbr type="sigle">ERTS</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid8" type="inproceedings" rend="year" n="cite:suzanne:hal-01360566">
      <identifiant type="doi" value="10.1007/978-3-662-53413-7_23"/>
      <identifiant type="hal" value="hal-01360566"/>
      <analytic>
        <title level="a">From Array Domains to Abstract Interpretation Under Store-Buffer-Based Memory Models</title>
        <author>
          <persName key="antique-2014-idp87720">
            <foreName>Thibault</foreName>
            <surname>Suzanne</surname>
            <initial>T.</initial>
          </persName>
          <persName key="antique-2014-idp68336">
            <foreName>Antoine</foreName>
            <surname>Miné</surname>
            <initial>A.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">SAS 2016 - 23rd Static Analysis Symposium</title>
        <loc>Edinburgh, United Kingdom</loc>
        <title level="s">Lecture Notes in Computer Science</title>
        <imprint>
          <biblScope type="volume">9837</biblScope>
          <publisher>
            <orgName>Springer</orgName>
          </publisher>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">469-488</biblScope>
          <ref xlink:href="http://hal.upmc.fr/hal-01360566" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01360566</ref>
        </imprint>
        <meeting id="cid311103">
          <title>International Static Analysis Symposium</title>
          <num>23</num>
          <abbr type="sigle">SAS</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid1" type="article" rend="foot" n="footcite:c:97:hierarchy">
      <identifiant type="doi" value="10.1016/S1571-0661(05)80168-9"/>
      <analytic>
        <title level="a">Constructive design of a hierarchy of semantics of a transition system by abstract interpretation</title>
        <author>
          <persName key="antique-2014-idm27896">
            <foreName>Patrick</foreName>
            <surname>Cousot</surname>
            <initial>P.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">Electr. Notes Theor. Comput. Sci.</title>
        <imprint>
          <biblScope type="volume">6</biblScope>
          <dateStruct>
            <year>1997</year>
          </dateStruct>
          <biblScope type="pages">77–102</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1016/S1571-0661(05)80168-9" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1016/<allowbreak/>S1571-0661(05)80168-9</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="antique-2016-bid0" type="inproceedings" rend="foot" n="footcite:cc:popl:77">
      <analytic>
        <title level="a">Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
        <author>
          <persName key="antique-2014-idm27896">
            <foreName>Patrick</foreName>
            <surname>Cousot</surname>
            <initial>P.</initial>
          </persName>
          <persName key="antique-2014-idm26552">
            <foreName>Radhia</foreName>
            <surname>Cousot</surname>
            <initial>R.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">Conference Record of the Fourth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
        <imprint>
          <publisher>
            <orgName>ACM Press, New York, United States</orgName>
          </publisher>
          <dateStruct>
            <year>1977</year>
          </dateStruct>
          <biblScope type="pages">238–252</biblScope>
        </imprint>
      </monogr>
    </biblStruct>
  </biblio>
</raweb>
