<?xml version="1.0" encoding="utf-8"?>
<raweb xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="en" year="2016">
  <identification id="gallium" isproject="true">
    <shortname>GALLIUM</shortname>
    <projectName>Programming languages, types, compilation and proofs</projectName>
    <theme-de-recherche>Proofs and Verification</theme-de-recherche>
    <domaine-de-recherche>Algorithmics, Programming, Software and Architecture</domaine-de-recherche>
    <urlTeam>http://gallium.inria.fr/</urlTeam>
    <header_dates_team>Creation of the Project-Team: 2006 May 01</header_dates_team>
    <LeTypeProjet>Project-Team</LeTypeProjet>
    <keywordsSdN>
      <term>1.1.3. - Memory models</term>
      <term>2.1.1. - Semantics of programming languages</term>
      <term>2.1.2. - Object-oriented programming</term>
      <term>2.1.3. - Functional programming</term>
      <term>2.1.6. - Concurrent programming</term>
      <term>2.1.11. - Proof languages</term>
      <term>2.2.1. - Static analysis</term>
      <term>2.2.2. - Memory models</term>
      <term>2.2.3. - Run-time systems</term>
      <term>2.2.4. - Parallel architectures</term>
      <term>2.4.1. - Analysis</term>
      <term>2.4.3. - Proofs</term>
      <term>2.5.4. - Software Maintenance &amp; Evolution</term>
      <term>4.5. - Formal methods for security</term>
      <term>7.1. - Parallel and distributed algorithms</term>
      <term>7.4. - Logic in Computer Science</term>
    </keywordsSdN>
    <keywordsSecteurs>
      <term>5.2.3. - Aviation</term>
      <term>6.1. - Software industry</term>
      <term>6.3.1. - Web</term>
      <term>6.5. - Information systems</term>
      <term>6.6. - Embedded systems</term>
      <term>9.4.1. - Computer science</term>
    </keywordsSecteurs>
    <UR name="Paris"/>
  </identification>
  <team id="uid1">
    <person key="gallium-2014-idm29528">
      <firstname>Xavier</firstname>
      <lastname>Leroy</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Team leader, Senior Researcher, Inria</moreinfo>
    </person>
    <person key="gallium-2014-idm28256">
      <firstname>Umut</firstname>
      <lastname>Acar</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Advanced Research position, Carnegie Mellon University</moreinfo>
    </person>
    <person key="toccata-2014-idp68328">
      <firstname>Arthur</firstname>
      <lastname>Charguéraud</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Researcher, Inria, 40%</moreinfo>
    </person>
    <person key="gallium-2014-idm26976">
      <firstname>Damien</firstname>
      <lastname>Doligez</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Researcher, Inria</moreinfo>
    </person>
    <person key="gallium-2014-idm25696">
      <firstname>Fabrice</firstname>
      <lastname>Le Fessant</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Researcher, Inria</moreinfo>
    </person>
    <person key="gallium-2014-idp66296">
      <firstname>Luc</firstname>
      <lastname>Maranget</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Researcher, Inria</moreinfo>
    </person>
    <person key="gallium-2016-idp121360">
      <firstname>Michel</firstname>
      <lastname>Mauny</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Senior Researcher, Inria</moreinfo>
    </person>
    <person key="gallium-2014-idp67496">
      <firstname>François</firstname>
      <lastname>Pottier</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Senior Researcher, Inria</moreinfo>
      <hdr>oui</hdr>
    </person>
    <person key="gallium-2016-idp126752">
      <firstname>Michael</firstname>
      <lastname>Rainey</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Starting Research position, Inria</moreinfo>
    </person>
    <person key="gallium-2014-idp70256">
      <firstname>Didier</firstname>
      <lastname>Rémy</lastname>
      <categoryPro>Chercheur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Senior Researcher, Inria</moreinfo>
      <hdr>oui</hdr>
    </person>
    <person key="gallium-2016-idp132096">
      <firstname>Sébastien</firstname>
      <lastname>Hinderer</lastname>
      <categoryPro>Technique</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Research Engineer, Inria, 70%, from Apr 2016</moreinfo>
    </person>
    <person key="gallium-2014-idp71704">
      <firstname>Pierre</firstname>
      <lastname>Courtieu</lastname>
      <categoryPro>Enseignant</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Associate Professor on délégation, CNAM, until Aug 2016</moreinfo>
    </person>
    <person key="parkas-2014-idp142896">
      <firstname>Adrien</firstname>
      <lastname>Guatto</lastname>
      <categoryPro>PostDoc</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, until Sep 2016</moreinfo>
    </person>
    <person key="gallium-2015-idp79904">
      <firstname>Filip</firstname>
      <lastname>Sieczkowski</lastname>
      <categoryPro>PostDoc</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, until Sep 2016</moreinfo>
    </person>
    <person key="gallium-2015-idp72464">
      <firstname>Vitalii</firstname>
      <lastname>Aksenov</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
    <person key="gallium-2015-idp84952">
      <firstname>Armaël</firstname>
      <lastname>Guéneau</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Lyon, from Sep 2016</moreinfo>
    </person>
    <person key="gallium-2014-idp82000">
      <firstname>Jacques-Henri</firstname>
      <lastname>Jourdan</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria, until Mar 2016, granted by ANR VERASCO project</moreinfo>
    </person>
    <person key="gallium-2014-idp84504">
      <firstname>Gabriel</firstname>
      <lastname>Scherer</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris and Inria, until Jan 2016</moreinfo>
    </person>
    <person key="gallium-2014-idp85776">
      <firstname>Thomas</firstname>
      <lastname>Williams</lastname>
      <categoryPro>PhD</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>ENS Paris</moreinfo>
    </person>
    <person key="gallium-2014-idp92112">
      <firstname>Jacques-Pascal</firstname>
      <lastname>Deplaix</lastname>
      <categoryPro>AutreCategorie</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Student Intern, Epitech, from Mar 2016 until Aug 2016</moreinfo>
    </person>
    <person key="gallium-2016-idp156896">
      <firstname>Felipe</firstname>
      <lastname>Garay</lastname>
      <categoryPro>AutreCategorie</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Student Intern, Universidad de Santiago de Chile, from Feb 2016 until Apr 2016</moreinfo>
    </person>
    <person key="gallium-2016-idp159328">
      <firstname>Andrea</firstname>
      <lastname>Parri</lastname>
      <categoryPro>Visiteur</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Sant'Anna School of Advanced Studies, Pisa, Italy, from May 2016 until Nov 2016</moreinfo>
    </person>
    <person key="gallium-2016-idp161872">
      <firstname>Ambroise</firstname>
      <lastname>Lafont</lastname>
      <categoryPro>AutreCategorie</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Student Intern, École Polytechnique, from Apr 2016 until August 2016</moreinfo>
    </person>
    <person key="polsys-2014-idp85904">
      <firstname>Laurence</firstname>
      <lastname>Bourcier</lastname>
      <categoryPro>Assistant</categoryPro>
      <research-centre>Paris</research-centre>
      <moreinfo>Inria</moreinfo>
    </person>
  </team>
  <presentation id="uid2">
    <bodyTitle>Overall Objectives</bodyTitle>
    <subsection id="uid3" level="1">
      <bodyTitle>Research at Gallium</bodyTitle>
      <p>The research conducted in the Gallium group aims at improving the
safety, reliability and security of software through advances in
programming languages and formal verification of programs. Our work
is centered on the design, formalization and implementation of
functional programming languages, with particular emphasis on type
systems and type inference, formal verification of compilers, and
interactions between programming and program proof. The OCaml language
and the CompCert verified C compiler embody many of our research
results. Our work spans the whole spectrum from theoretical
foundations and formal semantics to applications to real-world
problems.</p>
    </subsection>
  </presentation>
  <fondements id="uid4">
    <bodyTitle>Research Program</bodyTitle>
    <subsection id="uid5" level="1">
      <bodyTitle>Programming languages: design, formalization, implementation</bodyTitle>
      <p>Like all languages, programming languages are the media by which
thoughts (software designs) are communicated (development),
acted upon (program execution), and reasoned upon (validation).
The choice of adequate programming languages has a tremendous impact
on software quality. By “adequate”, we mean in particular the
following four aspects of programming languages:</p>
      <simplelist>
        <li id="uid6">
          <p noindent="true"><b>Safety.</b> The programming language must not expose
error-prone low-level operations (explicit memory deallocation,
unchecked array access, etc) to programmers. Further, it should
provide constructs for describing data structures, inserting
assertions, and expressing invariants within programs. The consistency
of these declarations and assertions should be verified through
compile-time verification (e.g. static type-checking) and run-time
checks.</p>
        </li>
        <li id="uid7">
          <p noindent="true"><b>Expressiveness.</b> A programming language should manipulate
as directly as possible the concepts and entities of the application
domain. In particular, complex, manual encodings of domain notions
into programmatic notations should be avoided as much as possible. A
typical example of a language feature that increases expressiveness is
pattern matching for examination of structured data (as in symbolic
programming) and of semi-structured data (as in XML processing).
Carried to the extreme, the search for expressiveness leads to
domain-specific languages, customized for a specific application area.</p>
        </li>
        <li id="uid8">
          <p noindent="true"><b>Modularity and compositionality.</b> The complexity of large
software systems makes it impossible to design and develop them as
one, monolithic program. Software decomposition (into semi-independent
components) and software composition (of existing or
independently-developed components) are therefore crucial. Again,
this modular approach can be applied to any programming language,
given sufficient fortitude by the programmers, but is much facilitated
by adequate linguistic support. In particular, reflecting notions of
modularity and software components in the programming language enables
compile-time checking of correctness conditions such as type
correctness at component boundaries.</p>
        </li>
        <li id="uid9">
          <p noindent="true"><b>Formal semantics.</b> A programming language should fully and
formally specify the behaviours of programs using mathematical
semantics, as opposed to informal, natural-language specifications.
Such a formal semantics is required in order to apply formal methods
(program proof, model checking) to programs.</p>
        </li>
      </simplelist>
      <p>Our research work in language design and implementation centers on
the statically-typed functional programming paradigm,
which scores high on safety, expressiveness and formal semantics,
complemented with full imperative features and objects for additional
expressiveness, and modules and classes for compositionality. The
OCaml language and system embodies many of our earlier
results in this area <ref xlink:href="#gallium-2016-bid0" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.
Through collaborations, we also gained experience with several
domain-specific languages based on a functional core, including
distributed programming (JoCaml), XML processing (XDuce, CDuce),
reactive functional programming, and hardware modeling.</p>
    </subsection>
    <subsection id="uid10" level="1">
      <bodyTitle>Type systems</bodyTitle>
      <p>Type systems  <ref xlink:href="#gallium-2016-bid1" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> are a very effective way to improve
programming language reliability. By grouping the data manipulated by
the program into classes called types, and ensuring that operations
are never applied to types over which they are not defined
(e.g. accessing an integer as if it were an array, or calling a string
as if it were a function), a tremendous number of programming errors
can be detected and avoided, ranging from the trivial (misspelled
identifier) to the fairly subtle (violation of data structure
invariants). These restrictions are also very effective at thwarting
basic attacks on security vulnerabilities such as buffer overflows.</p>
      <p>The enforcement of such typing restrictions is called type-checking,
and can be performed either dynamically (through run-time type tests)
or statically (at compile-time, through static program analysis). We
favor static type-checking, as it catches bugs earlier and even in
rarely-executed parts of the program, but note that not all type
constraints can be checked statically if static type-checking is to
remain decidable (i.e. not degenerate into full program proof).
Therefore, all typed languages combine static and dynamic
type-checking in various proportions.</p>
      <p>Static type-checking amounts to an automatic proof of
partial correctness of the programs that pass the compiler. The two
key words here are <i>partial</i>, since only type safety guarantees are
established, not full correctness; and <i>automatic</i>, since the
proof is performed entirely by machine, without manual assistance from
the programmer (beyond a few, easy type declarations in the source).
Static type-checking can therefore be viewed as the poor man's formal
methods: the guarantees it gives are much weaker than full formal
verification, but it is much more acceptable to the general population
of programmers.</p>
      <subsection id="uid11" level="2">
        <bodyTitle>Type systems and language design.</bodyTitle>
        <p>Unlike most other uses of static program analysis, static
type-checking rejects programs that it cannot prove safe.
Consequently, the type system is an integral part of the language
design, as it determines which programs are acceptable and which are
not. Modern typed languages go one step further: most of the language
design is determined by the <i>type structure</i> (type algebra and
typing rules) of the language and intended application area. This is
apparent, for instance, in the XDuce and CDuce domain-specific
languages for XML transformations <ref xlink:href="#gallium-2016-bid2" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, <ref xlink:href="#gallium-2016-bid3" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>,
whose design is driven by the idea of regular expression types that
enforce DTDs at compile-time. For this reason, research on type
systems – their design, their proof of semantic correctness (type
safety), the development and proof of associated type-checking and
inference algorithms – plays a large and central role in the field of
programming language research, as evidenced by the huge number of type
systems papers in conferences such as Principles of Programming
Languages.</p>
      </subsection>
      <subsection id="uid12" level="2">
        <bodyTitle>Polymorphism in type systems.</bodyTitle>
        <p>There exists a fundamental tension in the field of type systems that
drives much of the research in this area. On the one hand, the desire
to catch as many programming errors as possible leads to type systems
that reject more programs, by enforcing fine distinctions between
related data structures (say, sorted arrays and general arrays). The
downside is that code reuse becomes harder: conceptually identical
operations must be implemented several times (say, copying a general array
and a sorted array). On the other hand, the desire to support code
reuse and to increase expressiveness leads to type
systems that accept more programs, by assigning a common type to
broadly similar objects (for instance, the <tt>Object</tt> type of all class
instances in Java). The downside is a loss of precision in static
typing, requiring more dynamic type checks (downcasts in Java) and
catching fewer bugs at compile-time.</p>
        <p><i>Polymorphic</i> type systems offer a way out of this dilemma by
combining precise, descriptive types (to catch more errors statically)
with the ability to abstract over their differences in pieces of
reusable, generic code that is concerned only with their commonalities.
The paradigmatic example is parametric polymorphism, which is
at the heart of all typed functional programming
languages. Many forms of polymorphic typing have been studied since
then. Taking examples from our group, the work of Rémy, Vouillon and
Garrigue on row polymorphism <ref xlink:href="#gallium-2016-bid4" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, integrated
in OCaml, extended the benefits of this approach (reusable
code with no loss of typing precision) to object-oriented programming,
extensible records and extensible variants. Another example is the
work by Pottier on subtype polymorphism, using a constraint-based
formulation of the type system <ref xlink:href="#gallium-2016-bid5" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.
Finally, the notion of “coercion polymorphism” proposed by Cretin and
Rémy<ref xlink:href="#gallium-2016-bid6" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> combines and generalizes both parametric
and subtyping polymorphism.</p>
      </subsection>
      <subsection id="uid13" level="2">
        <bodyTitle>Type inference.</bodyTitle>
        <p>Another crucial issue in type systems research is the issue of type
inference: how many type annotations must be provided by the
programmer, and how many can be inferred (reconstructed) automatically
by the type-checker? Too many annotations make the language more
verbose and bother the programmer with unnecessary details. Too few
annotations make type-checking undecidable, possibly requiring
heuristics, which is unsatisfactory.
OCaml requires explicit type information at data type
declarations and at component interfaces, but infers all
other types.</p>
        <p>In order to be predictable, a type inference algorithm must be complete. That
is, it must not find <i>one</i>, but <i>all</i> ways of filling in the missing
type annotations to form an explicitly typed program. This task is made easier
when all possible solutions to a type inference problem are <i>instances</i>
of a single, <i>principal</i> solution.</p>
        <p>Maybe surprisingly, the strong requirements – such as the existence of
principal types – that are imposed on type systems by the desire to perform
type inference sometimes lead to better designs. An illustration of this is
row variables. The development of row variables was prompted by type inference
for operations on records. Indeed, previous approaches were based on subtyping
and did not easily support type inference. Row variables have proved simpler
than structural subtyping and more adequate for type-checking record update,
record extension, and objects.</p>
        <p>Type inference encourages abstraction and code reuse. A programmer's
understanding of his own program is often initially limited to a particular
context, where types are more specific than strictly required. Type inference
can reveal the additional generality, which allows making the code more
abstract and thus more reuseable.</p>
      </subsection>
    </subsection>
    <subsection id="uid14" level="1">
      <bodyTitle>Compilation</bodyTitle>
      <p>Compilation is the automatic translation of high-level programming
languages, understandable by humans, to lower-level languages, often
executable directly by hardware. It is an essential step in the
efficient execution, and therefore in the adoption, of high-level
languages. Compilation is at the interface between programming
languages and computer architecture, and because of this position has
had considerable influence on the design of both. Compilers have
also attracted considerable research interest as the oldest instance
of symbolic processing on computers.</p>
      <p>Compilation has been the topic of much research work in the last 40
years, focusing mostly on high-performance execution
(“optimization”) of low-level languages such as Fortran and C. Two
major results came out of these efforts: one is a superb body of
performance optimization algorithms, techniques and methodologies; the
other is the whole field of static program analysis, which now serves
not only to increase performance but also to increase reliability,
through automatic detection of bugs and establishment of safety
properties. The work on compilation carried out in the Gallium group
focuses on a less investigated topic: compiler certification.</p>
      <subsection id="uid15" level="2">
        <bodyTitle>Formal verification of compiler correctness.</bodyTitle>
        <p>While the algorithmic aspects of compilation (termination and
complexity) have been well studied, its semantic correctness – the
fact that the compiler preserves the meaning of programs – is
generally taken for granted. In other terms, the correctness of
compilers is generally established only through testing. This is
adequate for compiling low-assurance software, themselves validated
only by testing: what is tested is the executable code produced by the
compiler, therefore compiler bugs are detected along with application
bugs. This is not adequate for high-assurance, critical software
which must be validated using formal methods: what is formally
verified is the source code of the application; bugs in the compiler
used to turn the source into the final executable can invalidate the
guarantees so painfully obtained by formal verification of the source.</p>
        <p>To establish strong guarantees that the compiler can be trusted not
to change the behavior of the program, it is necessary to apply formal
methods to the compiler itself. Several approaches in this direction
have been investigated, including translation validation,
proof-carrying code, and type-preserving compilation. The approach
that we currently investigate, called <i>compiler verification</i>,
applies program proof techniques to the compiler itself, seen as a
program in particular, and use a theorem prover (the Coq system) to
prove that the generated code is observationally equivalent to the
source code. Besides its potential impact on the critical software
industry, this line of work is also scientifically fertile: it
improves our semantic understanding of compiler intermediate
languages, static analyses and code transformations.</p>
      </subsection>
    </subsection>
    <subsection id="uid16" level="1">
      <bodyTitle>Interface with formal methods</bodyTitle>
      <p>Formal methods collectively refer to the mathematical specification of
software or hardware systems and to the verification of these systems
against these specifications using computer assistance: model
checkers, theorem provers, program analyzers, etc. Despite their
costs, formal methods are gaining acceptance in the critical software
industry, as they are the only way to reach the required levels of
software assurance.</p>
      <p>In contrast with several other Inria projects, our research objectives
are not fully centered around formal methods. However, our research
intersects formal methods in the following two areas, mostly related
to program proofs using proof assistants and theorem provers.</p>
      <subsection id="uid17" level="2">
        <bodyTitle>Software-proof codesign</bodyTitle>
        <p>The current industrial practice is to write programs first, then
formally verify them later, often at huge costs. In contrast, we
advocate a codesign approach where the program and its proof of
correctness are developed in interaction, and we are interested in
developing ways and means to facilitate this approach. One
possibility that we currently investigate is to extend functional
programming languages such as OCaml with the ability to state
logical invariants over data structures and pre- and post-conditions
over functions, and interface with automatic or interactive provers to
verify that these specifications are satisfied. Another approach that
we practice is to start with a proof assistant such as Coq and improve
its capabilities for programming directly within Coq.</p>
      </subsection>
      <subsection id="uid18" level="2">
        <bodyTitle>Mechanized specifications and proofs for
programming languages components</bodyTitle>
        <p>We emphasize mathematical specifications and proofs of correctness for
key language components such as semantics, type systems, type
inference algorithms, compilers and static analyzers. These
components are getting so large that machine assistance becomes
necessary to conduct these mathematical investigations. We have
already mentioned using proof assistants to verify compiler
correctness. We are also interested in using them to specify and
reason about semantics and type systems. These efforts are part of a
more general research topic that is gaining importance: the formal
verification of the tools that participate in the construction and
certification of high-assurance software.</p>
      </subsection>
    </subsection>
  </fondements>
  <domaine id="uid19">
    <bodyTitle>Application Domains</bodyTitle>
    <subsection id="uid20" level="1">
      <bodyTitle>High-assurance software</bodyTitle>
      <p>A large part of our work on programming languages and tools focuses on
improving the reliability of software. Functional programming,
program proof, and static type-checking contribute significantly to
this goal.</p>
      <p>Because of its proximity with mathematical specifications,
pure functional programming is well suited to program proof.
Moreover, functional programming languages such as OCaml are eminently
suitable to develop the code generators and verification tools that
participate in the construction and qualification of high-assurance
software. Examples include Esterel Technologies's KCG 6 code
generator, the Astrée static analyzer, the
Caduceus/Jessie program prover, and the Frama-C platform. Our own
work on compiler verification combines these two aspects of functional
programming: writing a compiler in a pure functional language and
mechanically proving its correctness.</p>
      <p>Static typing detects programming errors early, prevents a number
of common sources of program crashes (null dereferences, out-of bound
array accesses, etc), and helps tremendously to enforce the integrity
of data structures. Judicious uses of generalized abstract data types
(GADTs), phantom types, type abstraction and other encapsulation
mechanisms also allow static type checking to enforce program
invariants.</p>
    </subsection>
    <subsection id="uid21" level="1">
      <bodyTitle>Software security</bodyTitle>
      <p>Static typing is also highly effective at preventing a number of
common security attacks, such as buffer overflows, stack smashing, and
executing network data as if it were code. Applications developed in
a language such as OCaml are therefore inherently more secure than
those developed in unsafe languages such as C.</p>
      <p>The methods used in designing type systems and establishing their
soundness can also deliver static analyses that automatically verify
some security policies. Two examples from our past work include Java
bytecode verification <ref xlink:href="#gallium-2016-bid7" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> and enforcement of
data confidentiality through type-based inference of information flow
and noninterference properties <ref xlink:href="#gallium-2016-bid8" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
    </subsection>
    <subsection id="uid22" level="1">
      <bodyTitle>Processing of complex structured data</bodyTitle>
      <p>Like most functional languages, OCaml is very well suited to expressing
processing and transformations of complex, structured data. It
provides concise, high-level declarations for data structures; a very
expressive pattern-matching mechanism to destructure data; and
compile-time exhaustiveness tests.
Therefore, OCaml is an excellent match for applications involving significant
amounts of symbolic processing: compilers, program analyzers and
theorem provers, but also (and less obviously) distributed
collaborative applications, advanced Web applications, financial
modeling tools, etc.</p>
    </subsection>
    <subsection id="uid23" level="1">
      <bodyTitle>Rapid development</bodyTitle>
      <p>Static typing is often criticized as being verbose (due to the additional
type declarations required) and inflexible (due to, for instance, class
hierarchies that must be fixed in advance). Its combination with type
inference, as in the OCaml language, substantially diminishes the
importance of these problems: type inference allows programs to be
initially written with few or no type declarations; moreover, the
OCaml approach to object-oriented programming completely separates the
class inheritance hierarchy from the type compatibility relation.
Therefore, the OCaml language is highly suitable for fast
prototyping and the gradual evolution of software prototypes into
final applications, as advocated by the popular “extreme
programming” methodology.</p>
    </subsection>
    <subsection id="uid24" level="1">
      <bodyTitle>Teaching programming</bodyTitle>
      <p>Our work on the Caml language family has an impact on the teaching of
programming. Caml Light is one of the programming
languages selected by the French Ministry of Education
for teaching Computer Science in <i>classes
préparatoires scientifiques</i>. OCaml is also widely used for
teaching advanced programming in engineering schools, colleges and
universities in France, the USA, and Japan.</p>
    </subsection>
  </domaine>
  <highlights id="uid25">
    <bodyTitle>Highlights of the Year</bodyTitle>
    <subsection id="uid26" level="1">
      <bodyTitle>Highlights of the Year</bodyTitle>
      <p>Xavier Leroy received the
<ref xlink:href="https://royalsociety.org/science-events-and-lectures/2016/11/milner-award-lecture/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">2016 Royal Society Milner Award</ref>
“in recognition of his exceptional achievements in computer programming
which includes the design and implementation of the OCaml programming
language”.</p>
      <p>Xavier Leroy received one of the two 2016 Van Wijngaarden Awards from
Centrum Wiskunde &amp; Informatica (Amsterdam).</p>
      <p>Xavier Leroy received the ACM SIGPLAN Most Influential POPL Paper
Award for his POPL 2006 paper, <i>Formal certification of a compiler
back-end or: programming a compiler with a proof assistant</i>
<ref xlink:href="#gallium-2016-bid9" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
    </subsection>
  </highlights>
  <logiciels id="uid27">
    <bodyTitle>New Software and Platforms</bodyTitle>
    <subsection id="uid28" level="1">
      <bodyTitle>CompCert</bodyTitle>
      <participants>
        <person key="gallium-2014-idm29528">
          <firstname>Xavier</firstname>
          <lastname>Leroy</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Sandrine</firstname>
          <lastname>Blazy</lastname>
          <moreinfo>team Celtique</moreinfo>
        </person>
        <person key="gallium-2014-idp82000">
          <firstname>Jacques-Henri</firstname>
          <lastname>Jourdan</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Bernhard</firstname>
          <lastname>Schommer</lastname>
          <moreinfo>AbsInt GmbH</moreinfo>
        </person>
        <p>.</p>
      </participants>
      <p>The CompCert project investigates the formal verification of realistic compilers usable for critical embedded software. Such verified compilers come with a mathematical, machine-checked proof that the generated executable code behaves exactly as prescribed by the semantics of the source program. By ruling out the possibility of compiler-introduced bugs, verified compilers strengthen the guarantees that can be obtained by applying formal methods to source programs. <ref xlink:href="http://www.absint.com" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">AbsInt Angewandte Informatik GmbH</ref> sells a commercial version of CompCert with long-term maintenance.</p>
      <simplelist>
        <li id="uid29">
          <p noindent="true">URL: <ref xlink:href="http://compcert.inria.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>compcert.<allowbreak/>inria.<allowbreak/>fr/</ref> (academic),
<ref xlink:href="http://www.absint.com/compcert/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>absint.<allowbreak/>com/<allowbreak/>compcert/</ref> (commercial).</p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid30" level="1">
      <bodyTitle>Diy</bodyTitle>
      <participants>
        <person key="gallium-2014-idp66296">
          <firstname>Luc</firstname>
          <lastname>Maranget</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Jade</firstname>
          <lastname>Alglave</lastname>
          <moreinfo>Microsoft Research, Cambridge</moreinfo>
        </person>
        <p>.</p>
      </participants>
      <p>The <b>diy</b> suite (for “Do It Yourself”) provides a set of tools for
testing shared memory models: the <b>litmus</b> tool for running tests on
hardware, various generators for producing tests from concise specifications,
and <b>herd</b>, a memory model simulator. Tests are small programs written
in x86, Power, ARM or generic (LISA) assembler that can thus be generated from
concise specifications, run on hardware, or simulated on top of memory models.
Test results can be handled and compared using additional tools. Recent
versions also take a subset of the C language as input, so as to test and
simulate the C11 model. Recent releases (“Seven”) provide a new license
(Cecill-B), a simplified build process and numerous features, including a
simple macro system that connects the C input language and LISA annotations.</p>
      <simplelist>
        <li id="uid31">
          <p noindent="true">URL: <ref xlink:href="http://diy.inria.fr/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>diy.<allowbreak/>inria.<allowbreak/>fr/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid32" level="1">
      <bodyTitle>Menhir</bodyTitle>
      <participants>
        <person key="gallium-2014-idp67496">
          <firstname>François</firstname>
          <lastname>Pottier</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Yann</firstname>
          <lastname>Régis-Gianas</lastname>
          <moreinfo>Université Paris Diderot</moreinfo>
        </person>
        <p>.</p>
      </participants>
      <p>Menhir is a LR(1) parser generator for the OCaml programming language. That is, Menhir compiles LR(1) grammar specifications down to OCaml code.</p>
      <simplelist>
        <li id="uid33">
          <p noindent="true">URL: <ref xlink:href="http://gallium.inria.fr/~fpottier/menhir/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>gallium.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>~fpottier/<allowbreak/>menhir/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid34" level="1">
      <bodyTitle>OCaml</bodyTitle>
      <participants>
        <person key="gallium-2014-idm26976">
          <firstname>Damien</firstname>
          <lastname>Doligez</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Alain</firstname>
          <lastname>Frisch</lastname>
          <moreinfo>LexiFi</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Jacques</firstname>
          <lastname>Garrigue</lastname>
          <moreinfo>Nagoya University</moreinfo>
        </person>
        <person key="gallium-2014-idm25696">
          <firstname>Fabrice</firstname>
          <lastname>Le Fessant</lastname>
        </person>
        <person key="gallium-2014-idm29528">
          <firstname>Xavier</firstname>
          <lastname>Leroy</lastname>
        </person>
        <person key="gallium-2014-idp66296">
          <firstname>Luc</firstname>
          <lastname>Maranget</lastname>
        </person>
        <person key="gallium-2014-idp84504">
          <firstname>Gabriel</firstname>
          <lastname>Scherer</lastname>
        </person>
        <person key="PASUSERID">
          <firstname>Mark</firstname>
          <lastname>Shinwell</lastname>
          <moreinfo>Jane Street</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Leo</firstname>
          <lastname>White</lastname>
          <moreinfo>Jane Street</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Jeremy</firstname>
          <lastname>Yallop</lastname>
          <moreinfo>OCaml Labs, Cambridge University</moreinfo>
        </person>
        <p>.</p>
      </participants>
      <p>The OCaml language is a functional programming language that combines safety with expressiveness through the use of a precise and flexible type system with automatic type inference. The OCaml system is a comprehensive implementation of this language, featuring two compilers (a bytecode compiler, for fast prototyping and interactive use, and a native-code compiler producing efficient machine code for x86, ARM, PowerPC and SPARC), a debugger, a documentation generator, a compilation manager, a package manager, and many libraries contributed by the user community.</p>
      <simplelist>
        <li id="uid35">
          <p noindent="true">URL: <ref xlink:href="http://ocaml.org/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>ocaml.<allowbreak/>org/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid36" level="1">
      <bodyTitle>OPAM Builder</bodyTitle>
      <participants>
        <person key="gallium-2014-idm25696">
          <firstname>Fabrice</firstname>
          <lastname>Le Fessant</lastname>
        </person>
      </participants>
      <p>OPAM Builder checks in real time the installability on a computer of all
packages after any modification of the OPAM repository. To achieve this
result, it uses smart mechanisms to compute incremental differences
between package updates, to be able to reuse cached compilations, and
go down from quadratic complexity to linear complexity.</p>
      <simplelist>
        <li id="uid37">
          <p noindent="true">URL: <ref xlink:href="http://github.com/OCamlPro/opam-builder" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>github.<allowbreak/>com/<allowbreak/>OCamlPro/<allowbreak/>opam-builder</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid38" level="1">
      <bodyTitle>PASL</bodyTitle>
      <participants>
        <person key="gallium-2016-idp126752">
          <firstname>Michael</firstname>
          <lastname>Rainey</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="toccata-2014-idp68328">
          <firstname>Arthur</firstname>
          <lastname>Charguéraud</lastname>
        </person>
        <person key="gallium-2014-idm28256">
          <firstname>Umut</firstname>
          <lastname>Acar</lastname>
        </person>
        <p>.</p>
      </participants>
      <p>PASL is a C++ library for writing parallel programs targeting the broadly available multicore computers. The library provides a high level interface and can still guarantee very good efficiency and performance, primarily due to its scheduling and automatic granularity control mechanisms.</p>
      <simplelist>
        <li id="uid39">
          <p noindent="true">URL: <ref xlink:href="http://deepsea.inria.fr/pasl/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>deepsea.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>pasl/</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid40" level="1">
      <bodyTitle>TLAPS</bodyTitle>
      <participants>
        <person key="gallium-2014-idm26976">
          <firstname>Damien</firstname>
          <lastname>Doligez</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Stefan</firstname>
          <lastname>Merz</lastname>
          <moreinfo>team Veridis</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Martin</firstname>
          <lastname>Riener</lastname>
          <moreinfo>team Veridis</moreinfo>
        </person>
      </participants>
      <p>TLAPS is a platform for developing and mechanically verifying proofs about
TLA+ specifications. The TLA+ proof language is hierarchical and explicit,
allowing a user to decompose the overall proof into independent proof steps.
TLAPS consists of a proof manager that interprets the proof language and
generates a collection of proof obligations that are sent to backend
verifiers. The current backends include the tableau-based prover Zenon for
first-order logic, Isabelle/TLA+, an encoding of TLA+ as an object logic in
the logical framework Isabelle, an SMT backend designed for use with any
SMT-lib compatible solver, and an interface to a decision procedure for
propositional temporal logic.</p>
      <simplelist>
        <li id="uid41">
          <p noindent="true">URL: <ref xlink:href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>tla.<allowbreak/>msr-inria.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>tlaps/<allowbreak/>content/<allowbreak/>Home.<allowbreak/>html</ref></p>
        </li>
      </simplelist>
    </subsection>
    <subsection id="uid42" level="1">
      <bodyTitle>Zenon</bodyTitle>
      <participants>
        <person key="gallium-2014-idm26976">
          <firstname>Damien</firstname>
          <lastname>Doligez</lastname>
          <moreinfo>
            <b>contact</b>
          </moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Guillaume</firstname>
          <lastname>Bury</lastname>
          <moreinfo>CNAM</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>David</firstname>
          <lastname>Delahaye</lastname>
          <moreinfo>CNAM</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Pierre</firstname>
          <lastname>Halmagrand</lastname>
          <moreinfo>team Deducteam</moreinfo>
        </person>
        <person key="PASUSERID">
          <firstname>Olivier</firstname>
          <lastname>Hermant</lastname>
          <moreinfo>MINES ParisTech</moreinfo>
        </person>
        <p>.</p>
      </participants>
      <p>Zenon is an automatic theorem prover based on the tableaux method. Given a first-order statement as input, it outputs a fully formal proof in the form of a Coq proof script. It has special rules for efficient handling of equality and arbitrary transitive relations. Although still in the prototype stage, it already gives satisfying results on standard automatic-proving benchmarks.</p>
      <p>Zenon is designed to be easy to interface with front-end tools (for example integration in an interactive proof assistant), and also to be easily retargeted to output scripts for different frameworks (for example, Isabelle and Dedukti).</p>
      <simplelist>
        <li id="uid43">
          <p noindent="true">URL: <ref xlink:href="http://zenon-prover.org/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>zenon-prover.<allowbreak/>org/</ref></p>
        </li>
      </simplelist>
    </subsection>
  </logiciels>
  <resultats id="uid44">
    <bodyTitle>New Results</bodyTitle>
    <subsection id="uid45" level="1">
      <bodyTitle>Formal verification of compilers and static analyzers</bodyTitle>
      <subsection id="uid46" level="2">
        <bodyTitle>The CompCert formally-verified compiler</bodyTitle>
        <participants>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Bernhard</firstname>
            <lastname>Schommer</lastname>
            <moreinfo>AbsInt GmbH</moreinfo>
          </person>
          <person key="gallium-2014-idp82000">
            <firstname>Jacques-Henri</firstname>
            <lastname>Jourdan</lastname>
          </person>
        </participants>
        <p>In the context of our work on compiler verification (§<ref xlink:href="#uid15" location="intern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>),
since 2005 we have been developing and
formally verifying a moderately-optimizing compiler for a large subset
of the C programming language, generating assembly code for the
PowerPC, ARM, and x86 architectures <ref xlink:href="#gallium-2016-bid10" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.
This compiler comprises a back-end, which translates the Cminor
intermediate language to PowerPC assembly, and is reusable for source
languages other than C <ref xlink:href="#gallium-2016-bid11" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>; and a
front-end, which translates the CompCert C subset of C to Cminor.
The compiler is mostly written within the specification language of
the Coq proof assistant, out of which Coq's extraction facility
generates executable OCaml code. The compiler comes with a 50000-line,
machine-checked Coq proof of semantic preservation, establishing that
the generated assembly code executes exactly as prescribed by the
semantics of the source C program.</p>
        <p>This year, the CompCert C compiler was improved in several directions:</p>
        <simplelist>
          <li id="uid47">
            <p noindent="true">The proof of semantic preservation was extended to account for
separate compilation and linking. (See section <ref xlink:href="#uid53" location="intern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.)</p>
          </li>
          <li id="uid48">
            <p noindent="true">Support for 64-bit target processors was added, while keeping
the original support for 32-bit processors. The x86 code generator,
initially 32-bit only, was extended to handle x86 64-bit as well.</p>
          </li>
          <li id="uid49">
            <p noindent="true">The generation of DWARF debugging information in <tt>-g</tt>
mode, developed last year for PowerPC, is now available for ARM and
x86 as well.</p>
          </li>
          <li id="uid50">
            <p noindent="true">The semantics of conversions from pointer types to the <tt>_Bool</tt>
type is fully defined again. (It was made temporarily undefined
while addressing issues with comparisons between the null pointer
and out-of-bound pointers.)</p>
          </li>
          <li id="uid51">
            <p noindent="true">More features of ISO C 2011 are supported, such as the
<tt>_Noreturn</tt> attribute, or anonymous members of struct and union
types.</p>
          </li>
          <li id="uid52">
            <p noindent="true">As a result of his research on implementing a correct parser for the C
language (§<ref xlink:href="#uid56" location="intern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>), Jacques-Henri Jourdan improved the
implementation of the parser.</p>
          </li>
        </simplelist>
        <p>Version 2.7 of CompCert was released in June 2016, incorporating most
of these enhancements, with the exception of 64-bit processor support
and anonymous members, which will be released Q1 2017.</p>
      </subsection>
      <subsection id="uid53" level="2">
        <bodyTitle>Separate compilation and linking in CompCert</bodyTitle>
        <participants>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Chung-Kil</firstname>
            <lastname>Hur</lastname>
            <moreinfo>KAIST, Seoul</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Jeehoon</firstname>
            <lastname>Kang</lastname>
            <moreinfo>KAIST, Seoul</moreinfo>
          </person>
        </participants>
        <p>Separate compilation (of multiple C source files into
multiple object files, followed by linking of the object files to
produce the final executable program) has been supported for a long
time by the CompCert implementation, but it was not accounted for by
CompCert's correctness proof. That proof established semantic
preservation in the case of a single, monolithic C source file which
is compiled at once to produce the final executable, but not in the
more general case of separate compilation and linking.</p>
        <p>Version 2.7 of CompCert, released this year, extends the proof of
semantic preservation in order to account for separate compilation and
linking. It follows the approach described by Kang, Kim, Hur, Dreyer
and Vafeiadis in their POPL 2016 paper <ref xlink:href="#gallium-2016-bid12" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> and
prototyped by Kang on CompCert 2.4. In this approach, the proof
considers a set of C compilation units, separately compiled to
assembly then linked, and shows that the resulting assembly program
preserves the semantics of the C program that would be obtained by
syntactic linking of the source C compilation units. The simplicity
of this approach follows from the fact that semantic preservation is
still shown between whole programs (after linking); there is no need
to give semantics to individual compilation units.
Xavier Leroy integrated the approach of Kang <i>et al.</i> into the
CompCert development, and extended it to several new optimization
passes that were not present in Kang's prototype implementation.</p>
      </subsection>
      <subsection id="uid54" level="2">
        <bodyTitle>Separation logic assertions for compiler verification</bodyTitle>
        <participants>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Timothy</firstname>
            <lastname>Bourke</lastname>
            <moreinfo>EPI Parkas</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Lélio</firstname>
            <lastname>Brun</lastname>
            <moreinfo>EPI Parkas</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Maxime</firstname>
            <lastname>Dénès</lastname>
            <moreinfo>EPI Marelle</moreinfo>
          </person>
        </participants>
        <p>Separation logic is a powerful tool to reason about imperative
programs. It is a Hoare-style program logic where preconditions and
postconditions are assertions about the contents of mutable state.
Those assertions are built in a compositional manner using a
separating conjunction operator.</p>
        <p>While effective to prove the correctness of a given program,
separation logic and program logics in general are less effective to
prove the correctness of a compiler or of a program transformation, in
particular because it is difficult to show preservation of
termination. The alternative approach that we investigated this year
consists in using the assertion language of separation logic, and in
particular its separating conjunction, in the context of a
conventional, CompCert-style proof of semantic preservation based on
simulation diagrams. Assertions from separation logic make it possible
to state the invariant that relates the memory states of the program
before and after the transformation in a compositional manner,
simplifying the proof that this invariant is preserved through
execution steps.</p>
        <p>This approach was developed and experimentally evaluated in in three case studies.</p>
        <p>The first case study was part of project CEEC and consisted in verifying a code
generator from a domain-specific, purely-functional intermediate
language down to the Clight language of CompCert. Xavier Leroy and
Maxime Dénès used ad-hoc separation logic assertions to describe the
memory states of the generated Clight programs, and in particular the
use of pointers to return multiple function results via “out”
parameters.</p>
        <p>The second case study was a complete rewrite of the Stacking pass of
the CompCert back-end and of its correctness proof, as part of the new
support for 64-bit architectures (§<ref xlink:href="#uid53" location="intern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>). For
this new proof, Xavier Leroy reused and improved the separation logic
assertions of the previous project, using a shallow embedding into Coq
instead of a deep embedding. Separating conjunctions are used to
specify the layout and current contents of the stack frames for every
compiled function, in a way that accommodates 32- and 64-bit registers
and pointer values equally well.</p>
        <p>The third use takes place in the context of the verified Lustre-to-C
compiler in development at team Parkas (see their activity report).
The final pass of this compiler translates a simple object-oriented
intermediate language, Obc, to CompCert's Clight. Timothy Bourke and
Lélio Brun used the separation logic assertions from the second
project to specify and reason about the Clight memory layout of the
Obc nested objects. Timothy Bourke and Xavier Leroy also extended the
separation logic with a “magic wand” operator. A paper on this
compiler verification project is under review.</p>
      </subsection>
      <subsection id="uid55" level="2">
        <bodyTitle>Formal verification of static analyzers based on abstract interpretation</bodyTitle>
        <participants>
          <person key="gallium-2014-idp82000">
            <firstname>Jacques-Henri</firstname>
            <lastname>Jourdan</lastname>
          </person>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Sandrine</firstname>
            <lastname>Blazy</lastname>
            <moreinfo>team Celtique</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>David</firstname>
            <lastname>Pichardie</lastname>
            <moreinfo>team Celtique</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Sylvain</firstname>
            <lastname>Boulmé</lastname>
            <moreinfo>Grenoble INP, VERIMAG</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Alexis</firstname>
            <lastname>Fouilhé</lastname>
            <moreinfo>Université Joseph Fourier de Grenoble, VERIMAG</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Michaël</firstname>
            <lastname>Périn</lastname>
            <moreinfo>Université Joseph Fourier de Grenoble, VERIMAG</moreinfo>
          </person>
        </participants>
        <p>In the context of the Verasco ANR project, we are investigating the
formal specification and verification in Coq of a realistic static
analyzer based on abstract interpretation. This static analyzer
handles a large subset of the C language (the same subset as the
CompCert compiler, minus recursion and dynamic allocation); supports a
combination of abstract domains, including relational domains; and
should produce usable alarms. The long-term goal is to obtain a static
analyzer that can be used to prove safety properties of real-world
embedded C code.</p>
        <p>This year, Jacques-Henri Jourdan published in his PhD
thesis <ref xlink:href="#gallium-2016-bid13" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> an in-depth description of the mode of
operation of the current version of the Verasco static analyzer. He
also presented at the NSAD workshop <ref xlink:href="#gallium-2016-bid14" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> the new
algorithms used in Verasco for the abstract domain of Octagons that he
developed in 2015.</p>
      </subsection>
      <subsection id="uid56" level="2">
        <bodyTitle>Correct parsing of C using LR(1)</bodyTitle>
        <participants>
          <person key="gallium-2014-idp82000">
            <firstname>Jacques-Henri</firstname>
            <lastname>Jourdan</lastname>
          </person>
          <person key="gallium-2014-idp67496">
            <firstname>François</firstname>
            <lastname>Pottier</lastname>
          </person>
        </participants>
        <p>The C programming language cannot be parsed directly using LR technology.
Indeed, the grammar described in the C standard exhibits ambiguities which are
addressed in English prose. On the implementation side, it is known from the
folklore that one can in fact use an LALR(1) parser to parse C, provided one
sets up a so-called “lexer hack” to perform on-the-fly disambiguation of
tokens, guided by the current state of the parser.</p>
        <p>However, Jacques-Henri Jourdan and François Pottier found that a correct
implementation of the “lexer hack” is, surprisingly, difficult. To clarify
this situation, they implemented a reference C11 parser using Menhir. They
invented new techniques that improve and simplify the “lexer hack”, so as to
write correct yet reasonably simple C11 parsers. They also created a test
suite of C programs that exhibit particularly challenging corner cases. This
work is described in a paper that is currently under review.</p>
      </subsection>
      <subsection id="uid57" level="2">
        <bodyTitle>A SPARK front-end for CompCert</bodyTitle>
        <participants>
          <person key="gallium-2014-idp71704">
            <firstname>Pierre</firstname>
            <lastname>Courtieu</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Zhi</firstname>
            <lastname>Zang</lastname>
            <moreinfo>Kansas University</moreinfo>
          </person>
        </participants>
        <p>SPARK is a language, and a platform, dedicated to developing and verifying
critical software. It is a subset of the Ada language. It shares with
Ada a strict typing discipline and gives strict guarantees in terms of
safety. SPARK goes one step further by disallowing certain
“dangerous” features, that is, those that are too
difficult to statically analyze (aliasing, references, etc). Given its
dedication to safety critical software, we think that the SPARK
platform can benefit from a certified compiler. We are working on
adding a SPARK front-end to the CompCert verified compiler.</p>
        <p>Defining a semantics for SPARK in Coq is previous joint work with Zhi Zang.
The current front-end is based on this semantics. The compiler has been
written and tested and the proofs of correctness are nearing completion.</p>
      </subsection>
    </subsection>
    <subsection id="uid58" level="1">
      <bodyTitle>Language design and type systems</bodyTitle>
      <subsection id="uid59" level="2">
        <bodyTitle>Types with unique inhabitants for code inference</bodyTitle>
        <participants>
          <person key="gallium-2014-idp84504">
            <firstname>Gabriel</firstname>
            <lastname>Scherer</lastname>
            <moreinfo>Northeastern University</moreinfo>
          </person>
          <person key="gallium-2014-idp70256">
            <firstname>Didier</firstname>
            <lastname>Rémy</lastname>
          </person>
        </participants>
        <p>Some programming language features (coercions, type-classes, implicits) rely
on inferring a part of the code that is determined by its usage context. In
order to better understand the theoretical underpinnings of this mechanism,
we ask: when is it the case that there is a unique program that could have
been guessed, or in other words, that all possible guesses result in
equivalent program fragments? Which types have a unique inhabitant?</p>
        <p>To approach the question of uniqueness, we build on work in proof theory on
canonical representations of proofs. Using the proofs-as-programs
correspondence, we adapt the logical technique of focusing to obtain canonical
program representations.</p>
        <p>In the setting of simply-typed lambda-calculus with sums, equipped with the
strong <formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mrow><mi>β</mi><mi>η</mi></mrow></math></formula>-equivalence, we show that uniqueness is decidable. We
present a saturating focused logic that introduces irreducible cuts on
positive types “as soon as possible”. Goal-directed proof search in this
logic gives an effective algorithm that returns either zero, one or two
distinct inhabitants for any given type.</p>
        <p>This work, which was previously presented at a
conference  <ref xlink:href="#gallium-2016-bid15" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> and was the main part of
Scherer's PhD dissertation <ref xlink:href="#gallium-2016-bid16" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, has been submitted for
journal publication.</p>
      </subsection>
      <subsection id="uid60" level="2">
        <bodyTitle>Refactoring with ornaments in ML</bodyTitle>
        <participants>
          <person key="gallium-2014-idp85776">
            <firstname>Thomas</firstname>
            <lastname>Williams</lastname>
          </person>
          <person key="gallium-2014-idp70256">
            <firstname>Didier</firstname>
            <lastname>Rémy</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>Thomas Williams and Didier Rémy continued working on ornaments for program
refactoring and program transformation in ML. Ornaments have been introduced
as a way to describe some changes in data type definitions that preserve their
recursive structure, reorganizing, adding, or dropping some pieces of data.
After a new data structure has been described as an ornament of an older one,
some functions operating on the bare structure can be partially or sometimes
totally lifted into functions operating on the ornamented structure.</p>
        <p>We have continued working on the decomposition of the algorithm in several
steps. Using ornament inference, we first elaborate an ML program into a
generic program, which can be seen as a template for all possible liftings of
the original program. The generic program is defined in a superset of ML. It
can then be instantiated with specific ornaments, and simplified back into an
ML program. We studied the semantics of this intermediate language and used
them to prove the correctness of the lifting, using logical relations
techniques. A paper describing this process was submitted to PLDI.</p>
        <p>On the practical side, we updated our prototype implementation to match our
theoretical presentation: we create the generic program, then instantiate it.
We then simplify the resulting term so that it remains readable to the
programmer, and output an ML program. In the case of refactoring (the
representation of a data type is modified without adding any data), the
transformation is still fully automatic.</p>
      </subsection>
    </subsection>
    <subsection id="uid61" level="1">
      <bodyTitle>Shared-memory parallelism</bodyTitle>
      <subsection id="uid62" level="2">
        <bodyTitle>Weak memory models</bodyTitle>
        <participants>
          <person key="gallium-2014-idp66296">
            <firstname>Luc</firstname>
            <lastname>Maranget</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Jade</firstname>
            <lastname>Alglave</lastname>
            <moreinfo>University College London–Microsoft Research, UK</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Patrick</firstname>
            <lastname>Cousot</lastname>
            <moreinfo>New York University</moreinfo>
          </person>
          <person key="gallium-2016-idp159328">
            <firstname>Andrea</firstname>
            <lastname>Parri</lastname>
            <moreinfo>Sant'Anna School of Advanced Studies, Pisa, Italy</moreinfo>
          </person>
        </participants>
        <p>Modern multi-core and multi-processor computers do not follow the intuitive
“Sequential Consistency” model that would define a concurrent execution as
the interleaving of the executions of its constituent threads and that would
command instantaneous writes to the shared memory. This situation is due both
to in-core optimisations such as speculative and out-of-order execution of
instructions, and to the presence of sophisticated (and cooperating) caching
devices between processors and memory. Luc Maranget took part in an
international research effort to define the semantics of the computers of the
multi-core era, and more generally of shared-memory parallel devices or
languages, with a clear focus on devices.</p>
        <p>More precisely, in 2016, Luc Maranget pursued his collaboration with Jade
Alglave and Patrick Cousot to extend “Cats”, a domain-specific language for
defining and executing weak memory models. Last year, a long article that
presents a precise semantics for “Cats” and a study and formalisation of the
HSA memory model was submitted. (The Heterogeneous System Architecture
foundation is an industry standards body targeting heterogeneous computing
devices.) As this article was rejected, a new paper, focused on the “Cats”
semantics, was submitted this year, while the definition of the HSA memory
model was made available on the web site of the HSA foundation
(<ref xlink:href="http://www.hsafoundation.com/standards/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>www.<allowbreak/>hsafoundation.<allowbreak/>com/<allowbreak/>standards/</ref>).</p>
        <p>This year, our team hosted Andrea Parri, a Ph.D. student (supervised by Mauro
Marinoni at Sant'Anna School of Advanced Studies, Pisa, Italy), for six
months. Luc Maranget and Andrea Parri collaborated with Paul McKenney (IBM),
Alan Stern (Harvard University) and Jade Alglave on the definition of a memory
model for the Linux kernel. A preliminary version of this work was presented
by Paul McKenney at the <i>2016 Linux Conference Europe</i>. While invited at
the Dagstuhl seminar “<i>Concurrency with Weak Memory Models...</i>”, Luc
Maranget demonstrated the Diy toolsuite and the “Cats” language. It is worth
noting that Cats models are being used independently of us by other
researchers, most notably by Yatin Manerkar and Caroline J. Trippel (Princeton
University) who discovered an anomaly in the published compilation scheme of
the C11 language down to the Power architecture.</p>
        <p>Luc Maranget also co-authored a paper that will be presented at
POPL 2017 <ref xlink:href="#gallium-2016-bid17" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. This work describes memory-model-aware
“mixed-size” semantics for the ARMv8 architecture and for the C11 and
Sequential Consistency models. A mixed-size semantics accounts for the
behaviour of systems that access memory at different granularity levels
(bytes, words, etc.) This is joint work with many researchers, including
Shaked Flur and other members of Peter Sewell's team (University of Cambridge)
as well as Mark Batty (University of Kent).</p>
      </subsection>
      <subsection id="uid63" level="2">
        <bodyTitle>Algorithms and data structures for parallel computing</bodyTitle>
        <participants>
          <person key="gallium-2014-idm28256">
            <firstname>Umut</firstname>
            <lastname>Acar</lastname>
          </person>
          <person key="gallium-2015-idp72464">
            <firstname>Vitalii</firstname>
            <lastname>Aksenov</lastname>
          </person>
          <person key="toccata-2014-idp68328">
            <firstname>Arthur</firstname>
            <lastname>Charguéraud</lastname>
          </person>
          <person key="parkas-2014-idp142896">
            <firstname>Adrien</firstname>
            <lastname>Guatto</lastname>
          </person>
          <person key="gallium-2016-idp126752">
            <firstname>Michael</firstname>
            <lastname>Rainey</lastname>
          </person>
          <person key="gallium-2015-idp79904">
            <firstname>Filip</firstname>
            <lastname>Sieczkowski</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>The ERC Deepsea project, with principal investigator Umut Acar,
started in June 2013 and is hosted by the Gallium team. This project
aims at developing techniques for parallel and self-adjusting
computation in the context of shared-memory multiprocessors (i.e.,
multicore platforms). The project is continuing work that began at Max
Planck Institute for Software Systems between 2010 and 2013. As part
of this project, we are developing a C++ library, called PASL, for
programming parallel computations at a high level of abstraction. We
use this library to evaluate new algorithms and data structures.
We obtained four main results this year.</p>
        <p>Our first result is a calculus for parallel computing on hardware
shared-memory computers such as modern multicores. Many languages for
writing parallel programs have been developed. These languages offer
several distinct abstractions for parallelism, such as fork-join,
async-finish, futures, etc. While they may seem similar, these
abstractions lead to different semantics, language design and
implementation decisions. In this project, we consider the question of
whether it would be possible to unify these approaches to
parallelism. To this end, we propose a calculus, called the
<i>DAG-calculus</i>, which can encode existing approaches to parallelism
based on fork-join, async-finish, and futures, and possibly
others. We have shown that the approach is realistic by presenting an
implementation in C++ and by performing an empirical evaluation.
This work was presented at ICFP 2016 <ref xlink:href="#gallium-2016-bid18" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
        <p>Our second result is a concurrent data structure that may be used
to efficiently determine when a concurrently-updated counter reaches
the value zero. Our data structure extends an existing data
structure called SNZI <ref xlink:href="#gallium-2016-bid19" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.
While the latter imposes a fixed number of threads, our structure
is able to dynamically grow in response to the increasing degree
of concurrency in the system.
We use our dynamic non-zero indicator data structure to derive an
efficient runtime representation of async/finish programs.
The async/finish paradigm for expressing parallelism is one that, in the past decade,
has become a part of many research-language implementations (e.g. X10)
and is now gaining traction in a number of mainstream languages, most notably Java.
The implementation of async/finish is challenging
because the finish-block mechanism permits, and even encourages,
computations in which a large number of threads are required to
synchronize on shared barriers, and this number is not statically known.
We present an implementation of async/finish and prove that,
in a model that takes contention into account,
the cost of synchronization of the async-ed threads is amortized
constant time, regardless of the number of threads.
We also present experimental evaluation suggesting that the
approach performs well in practice.
This work has been accepted for publication at PPoPP
<ref xlink:href="#gallium-2016-bid20" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
        <p>Our third result is an extended, polished presentation of our prior
work on granularity control for parallel algorithms
using user-provided complexity functions.
Granularity control denotes the problem of controlling the size of parallel
threads created in implicitly parallel programs.
If small threads are executed in parallel, the overheads due to thread
creation can overwhelm the benefits of parallelism.
If large threads are executed sequentially, processors may spin idle.
In our work, we show that, if we have an oracle able to approximately
predict the execution
time of every sub-task, then there exists a strategy that delivers provably
good performance. Moreover, we present empirical results showing that,
for simple recursive divide-and-conquer programs, we are able
to implement such an oracle simply by requiring the user to
annotate functions with their asymptotic complexity. The idea is to
estimate the constant factors that apply by conducting measures at runtime.
This work is described in depth in an article published in the Journal
of Functional Programming (JFP) <ref xlink:href="#gallium-2016-bid21" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
        <p>Our fourth result is an extension of our aforementioned granularity control
approach, with three major additions.
First, we have developed an algorithm that ensures convergence of the
estimators associated with the constant factors for all fork-join programs,
and not just for a small class of programs.
Second, we have built a theoretical analysis establishing bounds
for the overall overheads of the convergence phase.
Third, we have developed a C++ implementation accompanied with
an extensive experimental study covering several benchmarks from the
Problem Based Benchmark Suite (PBBS), a collection of high-quality
parallel algorithms that delivers state-of-the-art performance.
Even though our approach does not leverage a specific compiler
and does not require any magic constant to be hard-coded in the source programs,
our code either matches or exceeds the performance of the authors'
original, hand-tuned codes.
An article describing this work is in preparation.</p>
      </subsection>
    </subsection>
    <subsection id="uid64" level="1">
      <bodyTitle>The OCaml language and system</bodyTitle>
      <subsection id="uid65" level="2">
        <bodyTitle>OCaml</bodyTitle>
        <participants>
          <person key="gallium-2014-idm26976">
            <firstname>Damien</firstname>
            <lastname>Doligez</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Alain</firstname>
            <lastname>Frisch</lastname>
            <moreinfo>Lexifi SAS</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Jacques</firstname>
            <lastname>Garrigue</lastname>
            <moreinfo>University of Nagoya</moreinfo>
          </person>
          <person key="gallium-2016-idp132096">
            <firstname>Sébastien</firstname>
            <lastname>Hinderer</lastname>
          </person>
          <person key="gallium-2014-idm25696">
            <firstname>Fabrice</firstname>
            <lastname>Le Fessant</lastname>
          </person>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
          </person>
          <person key="gallium-2014-idp66296">
            <firstname>Luc</firstname>
            <lastname>Maranget</lastname>
          </person>
          <person key="gallium-2014-idp84504">
            <firstname>Gabriel</firstname>
            <lastname>Scherer</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Mark</firstname>
            <lastname>Shinwell</lastname>
            <moreinfo>Jane Street</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Leo</firstname>
            <lastname>White</lastname>
            <moreinfo>Jane Street</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Jeremy</firstname>
            <lastname>Yallop</lastname>
            <moreinfo>OCaml Labs, Cambridge University</moreinfo>
          </person>
        </participants>
        <p>This year, we released versions 4.03.0 and 4.04.0 of the OCaml system.
These are major releases that introduce a large number of new
features. The most important features are:</p>
        <simplelist>
          <li id="uid66">
            <p noindent="true">A new optimization subsystem called <i>flambda</i>, which does
inlining and specialization of functions as well as static allocation
of some data structures, etc.</p>
          </li>
          <li id="uid67">
            <p noindent="true"><i>ephemerons</i>: a generalization of weak pointers that is
better suited for memoization of mutually-recursive functions.</p>
          </li>
          <li id="uid68">
            <p noindent="true">A fine-grained memory profiler to help programmers understand
the allocation behavior of their programs.</p>
          </li>
          <li id="uid69">
            <p noindent="true"><i>unboxed types</i>: a user-controlled optimized representation
for some simple data types.</p>
          </li>
        </simplelist>
      </subsection>
      <subsection id="uid70" level="2">
        <bodyTitle>Infrastructure for OCaml</bodyTitle>
        <participants>
          <person key="gallium-2016-idp132096">
            <firstname>Sébastien</firstname>
            <lastname>Hinderer</lastname>
          </person>
        </participants>
        <p>Sébastien Hinderer worked on improving the test infrastructure of the OCaml
compiler. These tests aim at verifying that the compiler works as expected.
Currently, they are driven by a set of Makefiles which are hard to maintain
and extend and make it difficult to add new tests. Sébastien developed the
<tt>ocamltest</tt> driver, which parses test descriptions written in a
domain-specific language and runs the appropriate tests.</p>
        <p>Sébastien Hinderer also worked on merging the Makefiles used for building the
compiler under Unix and Windows. The existence of separate sets of Makefiles,
which is the result of a long development history, makes it especially hard to
maintain and extend the compiler's build system. Sébastien worked on
eliminating this redundancy, so that a single build system can be used on
every platform. This is a prerequisite for using the GNU <tt>autoconf</tt>
tools and for building easy-to-use cross-compilers for OCaml. A cross-compiler
is required, for instance, to build iOS apps using OCaml.</p>
      </subsection>
      <subsection id="uid71" level="2">
        <bodyTitle>Continuous integration of OCaml packages</bodyTitle>
        <participants>
          <person key="gallium-2014-idm25696">
            <firstname>Fabrice</firstname>
            <lastname>Le Fessant</lastname>
          </person>
        </participants>
        <p>OPAM is a repository of OCaml source packages. It is now advertised as the
official way of installing the OCaml distribution. To maintain a high level of
quality for the thousands of source packages distributed in the repository, it
is crucial to provide feedback to the developers on the impact of their
modifications to the repository, in real-time, despite the high churn and the
cascading costs of package recompilations.</p>
        <p>We have designed and prototyped a simple modular architecture for a service
that monitors the OPAM repository, and triggers recompilation of packages that
are impacted by the latest modifications to the repository, for all major and
minor OCaml versions since 3.12.1. Previous attempts to design such a system
have failed to scale, although they targeted cloud systems of thousands of
virtual machines. On the contrary, the new prototype has been deployed on a
single quadcore server, and has been able to follow the OPAM repository for
eight months, providing feedback in almost real-time. To achieve such a
result, it uses many optimizations and caching techniques, to make
recompilations as incremental as possible <ref xlink:href="#gallium-2016-bid22" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
      <subsection id="uid72" level="2">
        <bodyTitle>Global analyses of OCaml programs</bodyTitle>
        <participants>
          <person key="PASUSERID">
            <firstname>Thomas</firstname>
            <lastname>Blanc</lastname>
            <moreinfo>ENSTA-ParisTech &amp; OCamlPro</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Pierre</firstname>
            <lastname>Chambart</lastname>
            <moreinfo>OCamlPro</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Vincent</firstname>
            <lastname>Laviron</lastname>
            <moreinfo>OCamlPro</moreinfo>
          </person>
          <person key="gallium-2014-idm25696">
            <firstname>Fabrice</firstname>
            <lastname>Le Fessant</lastname>
          </person>
          <person key="gallium-2016-idp121360">
            <firstname>Michel</firstname>
            <lastname>Mauny</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>Exception handling in OCaml can be used for managing and reporting
errors, as well as to express complex control flow constructs. As
such, exceptions can be the source of errors, when, for instance, a
function that may raise an exception is called in a context where this
exception cannot be handled. In such situations, the program may fail
unexpectedly, and the source of the error can be difficult to
identify.</p>
        <p>This work aims at performing global static analyses of OCaml programs
using abstract interpretation techniques, with a particular
focus on the detection of uncaught exceptions. Starting from one
of the OCaml intermediate languages, we produce a hypergraph that
represents the program to be analyzed. Each node of this hypergraph is
a program state and each edge is an operation. Operations that may or
may not raise an exception (such as function calls) have one or two
successors. A fixpoint iteration is then performed on the graph, where
function application edges are dynamically replaced by the
corresponding subgraphs. In essence, environment information is
propagated through the graph, adding at each node a superset of all
possible values of each variable, until no additional information can
be found. A description of the framework was presented at the 2015 OCaml workshop.
We expect concrete results as well as Thomas Blanc's thesis manuscript
during 2017.</p>
      </subsection>
      <subsection id="uid73" level="2">
        <bodyTitle>Type-checking the OCaml intermediate languages</bodyTitle>
        <participants>
          <person key="PASUSERID">
            <firstname>Pierrick</firstname>
            <lastname>Couderc</lastname>
            <moreinfo>ENSTA-ParisTech &amp; OCamlPro</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Grégoire</firstname>
            <lastname>Henry</lastname>
            <moreinfo>OCamlPro</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Fabrice</firstname>
            <lastname>Le fessant</lastname>
          </person>
          <person key="gallium-2016-idp121360">
            <firstname>Michel</firstname>
            <lastname>Mauny</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>This work aims at propagating type information through the
intermediate languages used by the OCaml compiler. We started by the
design and implementation of a consistency checker of the
type-annotated abstract syntax trees (TASTs) produced by the OCaml
compiler. It appears that, when presented as inference rules, the
different cases of this TAST checker can be read as the rules of the
OCaml type system. Proving the correctness of (part of) the checker
would prove the soundness of the corresponding part of the OCaml type
system. A preliminary report on this work has been presented at the
17th Symposium on Trends in Functional Programming (TFP 2016).</p>
      </subsection>
      <subsection id="uid74" level="2">
        <bodyTitle>Optimizing OCaml for satisfiability problems</bodyTitle>
        <participants>
          <person key="PASUSERID">
            <firstname>Sylvain</firstname>
            <lastname>Conchon</lastname>
            <moreinfo>LRI, Univ. Paris Sud</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Albin</firstname>
            <lastname>Coquereau</lastname>
            <moreinfo>ENSTA-ParisTech</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Fabrice</firstname>
            <lastname>Le fessant</lastname>
          </person>
          <person key="gallium-2016-idp121360">
            <firstname>Michel</firstname>
            <lastname>Mauny</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>This work aims at improving the performance of the Alt-Ergo SMT solver,
implemented in OCaml. For safety reasons, the implementation of Alt-Ergo uses
as much as possible a functional programming style and persistent data
structures, which are sometimes less efficient that the imperative style and
mutable data structures. We would like to first obtain a better understanding
of the OCaml memory and cache behavior, so as to understand where efficiency
could be gained, and then design dedicated data structures (for instance,
semi-persistent data structures) and compare their efficiency to the current
ones. This work is still at a preliminary stage: we have selected benchmarks
and profiled their execution in order to discover sources of inefficiency.</p>
      </subsection>
      <subsection id="uid75" level="2">
        <bodyTitle>Type compatibility checking for dynamically loaded OCaml data</bodyTitle>
        <participants>
          <person key="PASUSERID">
            <firstname>Florent</firstname>
            <lastname>Balestrieri</lastname>
            <moreinfo>ENSTA-ParisTech</moreinfo>
          </person>
          <person key="gallium-2016-idp121360">
            <firstname>Michel</firstname>
            <lastname>Mauny</lastname>
          </person>
          <p>.</p>
        </participants>
        <p>The SecurOCaml project (FUI 18) aims at enhancing the OCaml language
and environment in order to make it more suitable for building secure
applications, following recommendations published by the French ANSSI
in 2013. Michel Mauny and Florent Balistrieri (ENSTA-ParisTech)
represent ENSTA-Paristech in this project for the two-year period
2016-2017.</p>
        <p>The goal of this first year was to design and produce an effective OCaml
implementation that checks whether a memory graph – typically the result
obtained by un-marshalling some data – is compatible with a given OCaml type,
following the algorithm designed by Henry <i>et al.</i> in 2012. As the
algorithm needs a runtime representation of OCaml types, Florent Balestrieri
implemented a library for generic programming in
OCaml <ref xlink:href="#gallium-2016-bid23" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. He also implemented a type-checker
which, when given a type and a memory graph, checks whether the former could
be the type of the latter. The algorithm handles sharing and polymorphism, but
currently supports neither functional values nor existential types.</p>
      </subsection>
      <subsection id="uid76" level="2">
        <bodyTitle>Pattern matching</bodyTitle>
        <participants>
          <person key="gallium-2014-idp66296">
            <firstname>Luc</firstname>
            <lastname>Maranget</lastname>
          </person>
          <person key="gallium-2014-idp84504">
            <firstname>Gabriel</firstname>
            <lastname>Scherer</lastname>
            <moreinfo>Northeastern University, Boston</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Thomas</firstname>
            <lastname>Réfis</lastname>
            <moreinfo>Jane Street LLC</moreinfo>
          </person>
        </participants>
        <p>A new pattern matching diagnostic message, which should help OCaml programmers
to detect rare but vicious programming errors, was integrated in the yearly
release of the OCaml compiler, and was presented at the OCaml Users and
Developers Workshop <ref xlink:href="#gallium-2016-bid24" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
      <subsection id="uid77" level="2">
        <bodyTitle>Error diagnosis in Menhir parsers</bodyTitle>
        <participants>
          <person key="gallium-2014-idp67496">
            <firstname>François</firstname>
            <lastname>Pottier</lastname>
          </person>
        </participants>
        <p>In 2015, François Pottier proposed a reachability algorithm for LR automata,
which he implemented in the Menhir parser generator. He applied this approach
to the C grammar in the front-end of the CompCert compiler, therefore allowing
CompCert to produce better syntax error messages. This work has been presented
at the conferences JFLA 2016 <ref xlink:href="#gallium-2016-bid25" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
and CC 2016 <ref xlink:href="#gallium-2016-bid26" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
    </subsection>
    <subsection id="uid78" level="1">
      <bodyTitle>Software specification and verification</bodyTitle>
      <subsection id="uid79" level="2">
        <bodyTitle>Step-indexing in program logics</bodyTitle>
        <participants>
          <person key="gallium-2015-idp79904">
            <firstname>Filip</firstname>
            <lastname>Sieczkowski</lastname>
          </person>
        </participants>
        <p>Filip Sieczkowski pursued a line of work focused on techniques for
formal reasoning about programs, in joint work with Lars Birkedal (Aarhus
University) and Kasper Svendsen (Cambridge University). A modern and
successful approach to grounding programs logics is to rely on so-called
step-indexed models. Filip and his co-authors solved a problem that arises in
most step-indexed models, due to a tight coupling between the unfoldings of a
recursive domain equation and evaluation steps. Their approach is based on the
use of transfinite step-indexing. This work appeared at ESOP 2016
<ref xlink:href="#gallium-2016-bid27" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
      <subsection id="uid80" level="2">
        <bodyTitle>TLA+</bodyTitle>
        <participants>
          <person key="gallium-2014-idm26976">
            <firstname>Damien</firstname>
            <lastname>Doligez</lastname>
          </person>
          <person key="PASUSERID">
            <firstname>Leslie</firstname>
            <lastname>Lamport</lastname>
            <moreinfo>Microsoft Research</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Martin</firstname>
            <lastname>Riener</lastname>
            <moreinfo>team VeriDis</moreinfo>
          </person>
          <person key="PASUSERID">
            <firstname>Stephan</firstname>
            <lastname>Merz</lastname>
            <moreinfo>team VeriDis</moreinfo>
          </person>
          <p>.</p>
        </participants>
        <p>Damien Doligez is head of the “Tools for Proofs” team in the
Microsoft-Inria Joint Centre. The aim of this project is to
extend the TLA+ language with a formal language for hierarchical
proofs, formalizing Lamport's ideas <ref xlink:href="#gallium-2016-bid28" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, and to
build tools for writing TLA+ specifications and mechanically
checking the proofs.</p>
        <p>Our rewrite of the TLAPS tools is almost done and we hope to do a
first release in the first quarter of 2017.</p>
      </subsection>
      <subsection id="uid81" level="2">
        <bodyTitle>Hash tables and iterators: a case study in program verification</bodyTitle>
        <participants>
          <person key="gallium-2014-idp67496">
            <firstname>François</firstname>
            <lastname>Pottier</lastname>
          </person>
        </participants>
        <p>In the setting of the Vocal ANR project, François Pottier developed the
the specification and proof of an (imperative, sequential) hash table
implementation, as found in the module <tt>Hashtbl</tt> of OCaml's standard
library. This data structure supports the usual dictionary operations
(insertion, lookup, and so on), as well as iteration via folds and iterators.
The code was verified using higher-order separation logic, embedded in Coq,
via Charguéraud's CFML tool and library. This work was presented at CPP
2017 <ref xlink:href="#gallium-2016-bid29" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. It can be viewed as a case study that should
help prepare the way for verifying other modules in the Vocal library.</p>
      </subsection>
      <subsection id="uid82" level="2">
        <bodyTitle>Read-only permissions in separation logic</bodyTitle>
        <participants>
          <person key="toccata-2014-idp68328">
            <firstname>Arthur</firstname>
            <lastname>Charguéraud</lastname>
          </person>
          <person key="gallium-2014-idp67496">
            <firstname>François</firstname>
            <lastname>Pottier</lastname>
          </person>
        </participants>
        <p>Separation Logic, as currently implemented in Charguéraud's CFML tool and
library, imposes a simple ownership discipline on mutable heap-allocated data
structures: a thread either has full read-write access to a data structure, or
has no access at all. This implies, for instance, that two threads cannot
temporarily share read-only access to a data structure. There exist more
flexible disciplines in the literature, such as “fractional permissions” and
“share algebras”, but they are much more complex.</p>
        <p>In the setting of the Vocal ANR project, Arthur Charguéraud and François
Pottier noted that it would be desirable to define an extension of Separation
Logic that allows temporary shared read-only access, yet remains very simple.
They proposed a general mechanism for temporarily converting any assertion (or
“permission”) to a read-only form. The metatheory of this proposal has been
verified in Coq. This work will be presented at ESOP 2017 <ref xlink:href="#gallium-2016-bid30" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
        <p>Charguéraud and Pottier believe that this mechanism should allow more concise
specifications and proofs. This remains to be confirmed, in future work, via
an implementation in CFML and case studies in the Vocal project.</p>
      </subsection>
      <subsection id="uid83" level="2">
        <bodyTitle>Formal reasoning about asymptotic complexity</bodyTitle>
        <participants>
          <person key="gallium-2015-idp84952">
            <firstname>Armaël</firstname>
            <lastname>Guéneau</lastname>
          </person>
          <person key="toccata-2014-idp68328">
            <firstname>Arthur</firstname>
            <lastname>Charguéraud</lastname>
          </person>
          <person key="gallium-2014-idp67496">
            <firstname>François</firstname>
            <lastname>Pottier</lastname>
          </person>
        </participants>
        <p>Armaël Guéneau started his Ph.D. at Gallium in September 2016, supervised by
Arthur Charguéraud and François Pottier. In the line of his previous M2
internship at Gallium, he continued his work on asymptotic reasoning in Coq.
The challenge is to give a formal definition of the well-known big-<formula type="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll"><mi>O</mi></math></formula>
notation, covering both single-variable and multiple-variable scenarios, to
establish its fundamental properties, and to define tactics that make
asymptotic reasoning as convenient in Coq as it seemingly is on paper. The
ultimate goal is to apply these techniques to machine-checked proofs of the
asymptotic time complexity of programs.</p>
      </subsection>
      <subsection id="uid84" level="2">
        <bodyTitle>Certified distributed algorithms for autonomous mobile robots</bodyTitle>
        <participants>
          <person key="gallium-2014-idp71704">
            <firstname>Pierre</firstname>
            <lastname>Courtieu</lastname>
          </person>
        </participants>
        <p>The variety and complexity of the tasks that can be performed by autonomous robots
are increasing. Many applications envision groups of mobile robots that
self-organise and cooperate toward the resolution of common
objectives, in the absence of any central coordinating authority.</p>
        <p>Pierre Courtieu is elaborating a verification platform, based on Coq, for
distributed algorithms for autonomous robots. (This is joint work with Xavier
Urbain, Sebastien Tixeuil and Lionel Rieg.) As part of this effort, Pierre
Courtieu designed and verified a protocol for mobile robots that achieves the
“gathering” task in all cases where it has not been proved impossible
<ref xlink:href="#gallium-2016-bid31" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, <ref xlink:href="#gallium-2016-bid32" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
    </subsection>
  </resultats>
  <contrats id="uid85">
    <bodyTitle>Bilateral Contracts and Grants with Industry</bodyTitle>
    <subsection id="uid86" level="1">
      <bodyTitle>Bilateral Contracts with Industry</bodyTitle>
      <subsection id="uid87" level="2">
        <bodyTitle>The Caml Consortium</bodyTitle>
        <participants>
          <person key="gallium-2014-idm29528">
            <firstname>Xavier</firstname>
            <lastname>Leroy</lastname>
            <moreinfo>
              <b>contact</b>
            </moreinfo>
          </person>
          <person key="gallium-2014-idm26976">
            <firstname>Damien</firstname>
            <lastname>Doligez</lastname>
          </person>
          <person key="gallium-2014-idp70256">
            <firstname>Didier</firstname>
            <lastname>Rémy</lastname>
          </person>
        </participants>
        <p>The Caml Consortium is a formal structure where industrial and
academic users of OCaml can support the development of the language and
associated tools, express their specific needs, and contribute to the
long-term stability of Caml. Membership fees are used to fund
specific developments targeted towards industrial users. Members of
the Consortium automatically benefit from very liberal licensing
conditions on the OCaml system, allowing for instance the OCaml
compiler to be embedded within proprietary applications.</p>
        <p>The Consortium currently has 14 member companies:</p>
        <simplelist>
          <li id="uid88">
            <p noindent="true">Aesthetic Integration</p>
          </li>
          <li id="uid89">
            <p noindent="true">Ahrefs</p>
          </li>
          <li id="uid90">
            <p noindent="true">Bloomberg</p>
          </li>
          <li id="uid91">
            <p noindent="true">CEA</p>
          </li>
          <li id="uid92">
            <p noindent="true">Citrix</p>
          </li>
          <li id="uid93">
            <p noindent="true">Dassault Aviation</p>
          </li>
          <li id="uid94">
            <p noindent="true">Esterel Technologies</p>
          </li>
          <li id="uid95">
            <p noindent="true">Facebook</p>
          </li>
          <li id="uid96">
            <p noindent="true">Jane Street</p>
          </li>
          <li id="uid97">
            <p noindent="true">Kernelyze</p>
          </li>
          <li id="uid98">
            <p noindent="true">LexiFi</p>
          </li>
          <li id="uid99">
            <p noindent="true">Microsoft</p>
          </li>
          <li id="uid100">
            <p noindent="true">OCamlPro</p>
          </li>
          <li id="uid101">
            <p noindent="true">SimCorp</p>
          </li>
        </simplelist>
        <p>For a complete description of this
structure, refer to <ref xlink:href="http://caml.inria.fr/consortium/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>caml.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>consortium/</ref>.
Xavier Leroy chairs the scientific committee of the Consortium.</p>
      </subsection>
      <subsection id="uid102" level="2">
        <bodyTitle>Scientific Advisory for OCamlPro</bodyTitle>
        <participants>
          <person key="gallium-2014-idm25696">
            <firstname>Fabrice</firstname>
            <lastname>Le Fessant</lastname>
          </person>
        </participants>
        <p>OCamlPro is a startup company founded in 2011 by Fabrice Le Fessant to
promote the use of OCaml in the industry, by providing support,
services and tools for OCaml to software companies. OCamlPro performs
a lot of research and development, in close partnership with academic
institutions such as IRILL, Inria and Univ. Paris Sud, and is involved
in several collaborative projects with Gallium, such as the Bware ANR,
the Vocal ANR and the Secur-OCaml FUI.</p>
        <p>Since 2011, Fabrice Le Fessant is a scientific advisor at OCamlPro, as
part of a collaboration contract for Inria, to transfer his knowledge
on the internals of the OCaml runtime and the OCaml compilers.</p>
      </subsection>
    </subsection>
  </contrats>
  <partenariat id="uid103">
    <bodyTitle>Partnerships and Cooperations</bodyTitle>
    <subsection id="uid104" level="1">
      <bodyTitle>National Initiatives</bodyTitle>
      <subsection id="uid105" level="2">
        <bodyTitle>ANR projects</bodyTitle>
        <subsection id="uid106" level="3">
          <bodyTitle>BWare</bodyTitle>
          <participants>
            <person key="gallium-2014-idm26976">
              <firstname>Damien</firstname>
              <lastname>Doligez</lastname>
            </person>
            <person key="gallium-2014-idm25696">
              <firstname>Fabrice</firstname>
              <lastname>Le Fessant</lastname>
            </person>
          </participants>
          <p>The “BWare” project (2012–2016) is coordinated by David Delahaye at
Conservatoire National des Arts et Métiers and funded by the <i>Ingénierie Numérique et Sécurité</i> programme of <i>Agence Nationale de
la Recherche</i>. BWare is an industrial research project that aims to
provide a mechanized framework to support the automated verification
of proof obligations coming from the development of industrial
applications using the B method and requiring high guarantees of
confidence.</p>
        </subsection>
        <subsection id="uid107" level="3">
          <bodyTitle>Verasco</bodyTitle>
          <participants>
            <person key="gallium-2014-idp82000">
              <firstname>Jacques-Henri</firstname>
              <lastname>Jourdan</lastname>
            </person>
            <person key="gallium-2014-idm29528">
              <firstname>Xavier</firstname>
              <lastname>Leroy</lastname>
            </person>
          </participants>
          <p>The “Verasco” project (2012–2016) is coordinated by Xavier Leroy and
funded by the <i>Ingéniérie Numérique et Sécurité</i> programme of <i>Agence Nationale de la Recherche</i>. The objective of this 4.5-year
project is to develop and formally verify a static analyzer based on
abstract interpretation, and interface it with the CompCert C verified
compiler.</p>
        </subsection>
        <subsection id="uid108" level="3">
          <bodyTitle>Vocal</bodyTitle>
          <participants>
            <person key="gallium-2014-idm29528">
              <firstname>Xavier</firstname>
              <lastname>Leroy</lastname>
            </person>
            <person key="gallium-2014-idp67496">
              <firstname>François</firstname>
              <lastname>Pottier</lastname>
            </person>
            <p>.</p>
          </participants>
          <p>The “Vocal” project (2015–2020) aims at developing the first mechanically
verified library of efficient general-purpose data structures and algorithms.
It is funded by <i>Agence Nationale de la Recherche</i> under its “appel à
projets générique 2015”.</p>
          <p>The library will be made available to all OCaml programmers and will
be of particular interest to implementors of safety-critical OCaml programs,
such as Coq, Astrée, Frama-C, CompCert, Alt-Ergo, as well as new projects. By
offering verified program components, our work will provide the essential
building blocks that are needed to significantly decrease the cost of
developing new formally verified programs.</p>
        </subsection>
      </subsection>
      <subsection id="uid109" level="2">
        <bodyTitle>FSN projects</bodyTitle>
        <subsection id="uid110" level="3">
          <bodyTitle>ADN4SE</bodyTitle>
          <participants>
            <person key="gallium-2014-idm26976">
              <firstname>Damien</firstname>
              <lastname>Doligez</lastname>
            </person>
            <person key="PASUSERID">
              <firstname>Martin</firstname>
              <lastname>Riener</lastname>
            </person>
          </participants>
          <p>The “ADN4SE” project (2012–2016) is coordinated by the Sherpa
Engineering company and funded by the <i>Briques Génériques du
Logiciel Embarqué</i> programme of <i>Fonds national pour la
Société Numérique</i>. The aim of this project is to develop a process and a
set of tools to support the rapid development of embedded software
with strong safety constraints.
Gallium is involved in this project to provide tools and help for the
formal verification in TLA+ of some important aspects of the PharOS
real-time kernel, on which the whole project is based.</p>
        </subsection>
      </subsection>
      <subsection id="uid111" level="2">
        <bodyTitle>FUI Projects</bodyTitle>
        <subsection id="uid112" level="3">
          <bodyTitle>Secur-OCaml</bodyTitle>
          <participants>
            <person key="gallium-2014-idm26976">
              <firstname>Damien</firstname>
              <lastname>Doligez</lastname>
            </person>
            <person key="gallium-2014-idm25696">
              <firstname>Fabrice</firstname>
              <lastname>Le Fessant</lastname>
            </person>
          </participants>
          <p>The “Secur-OCaml” project (2015–2018) is coordinated by the
OCamlPro company, with a consortium focusing on the use of OCaml in
security-critical contexts, while OCaml is currently mostly used in
safety-critical contexts. Gallium is invoved in this project to
integrate security features in the OCaml language, to build a new
independant interpreter for the language, and to update the
recommendations for developers issued by the former LaFoSec project of
ANSSI.</p>
        </subsection>
      </subsection>
    </subsection>
    <subsection id="uid113" level="1">
      <bodyTitle>European Initiatives</bodyTitle>
      <subsection id="uid114" level="2">
        <bodyTitle>FP7 &amp; H2020 Projects</bodyTitle>
        <subsection id="uid115" level="3">
          <bodyTitle>Deepsea</bodyTitle>
          <participants>
            <person key="gallium-2014-idm28256">
              <firstname>Umut</firstname>
              <lastname>Acar</lastname>
            </person>
            <person key="gallium-2015-idp72464">
              <firstname>Vitalii</firstname>
              <lastname>Aksenov</lastname>
            </person>
            <person key="toccata-2014-idp68328">
              <firstname>Arthur</firstname>
              <lastname>Charguéraud</lastname>
            </person>
            <person key="gallium-2016-idp126752">
              <firstname>Michael</firstname>
              <lastname>Rainey</lastname>
            </person>
            <person key="gallium-2015-idp79904">
              <firstname>Filip</firstname>
              <lastname>Sieczkowski</lastname>
            </person>
            <p>.</p>
          </participants>
          <p>The Deepsea project (2013–2018) is coordinated by Umut Acar and funded by FP7
as an ERC Starting Grant.
Its objective is to develop abstractions, algorithms and languages for
parallelism and dynamic parallelism, with applications to problems on large
data sets.</p>
        </subsection>
      </subsection>
      <subsection id="uid116" level="2">
        <bodyTitle>ITEA3 Projects</bodyTitle>
        <subsection id="uid117" level="3">
          <bodyTitle>Assume</bodyTitle>
          <participants>
            <person key="gallium-2014-idm29528">
              <firstname>Xavier</firstname>
              <lastname>Leroy</lastname>
            </person>
            <person key="gallium-2014-idp66296">
              <firstname>Luc</firstname>
              <lastname>Maranget</lastname>
            </person>
            <p>.</p>
          </participants>
          <p>ASSUME (2015–2018) is an ITEA3 project involving France, Germany,
Netherlands, Turkey and Sweden. The French participants are
coordinated by Jean Souyris (Airbus) and include Airbus, Kalray,
Sagem, ENS Paris, and Inria Paris. The goal of the project is to
investigate the usability of multicore and manycore processors for
critical embedded systems. Our involvement in this project focuses on
the formalisation and verification of memory models and of automatic
code generators from reactive languages.</p>
        </subsection>
      </subsection>
    </subsection>
    <subsection id="uid118" level="1">
      <bodyTitle>International Initiatives</bodyTitle>
      <subsection id="uid119" level="2">
        <bodyTitle>Inria International Partners</bodyTitle>
        <subsection id="uid120" level="3">
          <bodyTitle>Informal International Partners</bodyTitle>
          <simplelist>
            <li id="uid121">
              <p noindent="true">Princeton University: interactions between
the CompCert verified C compiler and the Verified Software Toolchain
developed at Princeton.</p>
            </li>
            <li id="uid122">
              <p noindent="true">Cambridge University and Microsoft Research Cambridge:
formal modeling and testing of weak memory models.</p>
            </li>
          </simplelist>
        </subsection>
      </subsection>
    </subsection>
  </partenariat>
  <diffusion id="uid123">
    <bodyTitle>Dissemination</bodyTitle>
    <subsection id="uid124" level="1">
      <bodyTitle>Promoting Scientific Activities</bodyTitle>
      <subsection id="uid125" level="2">
        <bodyTitle>Scientific Events Organisation</bodyTitle>
        <subsection id="uid126" level="3">
          <bodyTitle>Member of the Organizing Committees</bodyTitle>
          <p>Michel Mauny is a member of the steering committee of the OCaml workshop.</p>
          <p>Didier Rémy was a member of the steering committee of the OCaml workshop until
September 2017. He is a member of the steering committee of the ML Family workshop.</p>
        </subsection>
      </subsection>
      <subsection id="uid127" level="2">
        <bodyTitle>Scientific Events Selection</bodyTitle>
        <subsection id="uid128" level="3">
          <bodyTitle>Member of the Conference Program Committees</bodyTitle>
          <p>Xavier Leroy was a member of the program committees of the Compiler
Construction conference (CC 2016), of the conference on Interactive
Theorem Proving (ITP 2016), and on the external review committee of the
symposium on Principles of Programming Languages (POPL 2017).</p>
          <p>François Pottier was a member of the program committees of the conferences
Journées Francophones des Langages Applicatifs (JFLA 2017)
and
Compiler Construction (CC 2017).</p>
        </subsection>
        <subsection id="uid129" level="3">
          <bodyTitle>Reviewer</bodyTitle>
          <p>In 2016, the members of Gallium reviewed at least 30 conference submissions.</p>
        </subsection>
      </subsection>
      <subsection id="uid130" level="2">
        <bodyTitle>Journal</bodyTitle>
        <subsection id="uid131" level="3">
          <bodyTitle>Member of the Editorial Boards</bodyTitle>
          <p>Xavier Leroy is area editor (programming languages) for the Journal of the
ACM. He is on the editorial board for the Research Highlights column of
Communications of the ACM. He is a member of the editorial board of the
Journal of Automated Reasoning.</p>
          <p>François Pottier is an editor for the Journal of Functional Programming.</p>
        </subsection>
      </subsection>
      <subsection id="uid132" level="2">
        <bodyTitle>Invited Talks</bodyTitle>
        <p>Xavier Leroy was an invited speaker at the ICALP conference (Rome, July 2016).</p>
      </subsection>
      <subsection id="uid133" level="2">
        <bodyTitle>Research Administration</bodyTitle>
        <p>Xavier Leroy is <i>délégué scientifique adjoint</i> of Inria
Paris and appointed member of Inria's <i>Commission
d'Évaluation</i>. He participated in the following Inria hiring and
promotion committees: <i>jury d'admissibilité DR2</i>,
<i>promotions CR1</i>, and <i>promotions DR1</i>.</p>
        <p>Xavier Leroy was a member of the hiring committee for a professor
position at Université de Lorraine.</p>
        <p>Xavier Leroy was a member of the HCERES evaluation panel for the LORIA
laboratory.</p>
        <p>François Pottier is a member of the <i>Commission de Développement
Technologique</i> and (as of January 2016) chairs the <i>Comité de Suivi
Doctoral</i> of Inria Paris.</p>
        <p>Didier Rémy is <i>Deputy Scientific Director</i> (ADS) in change of
<i>Algorithmics, Programming, Software and Architecture</i>.</p>
      </subsection>
    </subsection>
    <subsection id="uid134" level="1">
      <bodyTitle>Teaching - Supervision - Juries</bodyTitle>
      <subsection id="uid135" level="2">
        <bodyTitle>Teaching</bodyTitle>
        <sanspuceslist>
          <li id="uid136">
            <p noindent="true">Master:
Xavier Leroy and Didier Rémy,
“Functional programming languages”,
15+18h,
M2 (MPRI),
Université Paris Diderot,
France.</p>
          </li>
          <li id="uid137">
            <p noindent="true">Master:
Luc Maranget,
“Semantics, languages and algorithms for multi-core programming”,
13.5h,
M2 (MPRI),
Université Paris Diderot,
France.</p>
          </li>
          <li id="uid138">
            <p noindent="true">Master:
“Principles of Programming Languages”,
32h, M1,
ENSTA-ParisTech,
France.</p>
          </li>
          <li id="uid139">
            <p noindent="true">Licence:
François Pottier,
“Programmation avancée” (INF441),
20h, L3,
École Polytechnique,
France.</p>
          </li>
          <li id="uid140">
            <p noindent="true">Master:
François Pottier,
“Compilation” (INF564),
20h,
M1,
École Polytechnique,
France.</p>
          </li>
          <li id="uid141">
            <p noindent="true">Licence:
Michael Rainey and Umut Acar,
“Theory and practice of parallel computing”
(part of a longer course entitled 15-210, “Parallel and Sequential Data Structures and Algorithms”),
9h, L3, Carnegie Mellon University,
USA.</p>
          </li>
        </sanspuceslist>
        <p>Michel Mauny has been a Professor at ENSTA-ParisTech from August 1st, 2005 to
July 31st, 2016. While at ENSTA-ParisTech, Michel Mauny was in charge of the
specialization “Architecture and Security of Information Systems” (MSc. 2nd
year).</p>
        <p>François Pottier has been a Professeur Chargé de Cours at École Polytechnique
from September 1st, 2004 to August 31st, 2016.</p>
        <p>Didier Rémy is Inria's delegate in the pedagogical team of the MPRI.</p>
        <p>Fabrice Le Fessant has been involved in the second edition of the OCaml MOOC
on the FUN platform, in coordination with the OCamlPro team in charge of the
development of the exercise platform <ref xlink:href="#gallium-2016-bid33" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>
      </subsection>
      <subsection id="uid142" level="2">
        <bodyTitle>Supervision</bodyTitle>
        <sanspuceslist>
          <li id="uid143">
            <p noindent="true">M2 (Master Pro):
Jacques-Pascal Deplaix,
Epitech,
supervised by François Pottier.</p>
          </li>
          <li id="uid144">
            <p noindent="true">M2 (MPRI):
Ambroise Lafont,
École Polytechnique,
supervised by Xavier Leroy.</p>
          </li>
          <li id="uid145">
            <p noindent="true">PhD:
Pierre Halmagrand,
“Automated Deduction and Proof Certification for the B Method”  <ref xlink:href="#gallium-2016-bid34" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>,
Conservatoire National des Arts et Métiers,
defended December 10, 2016,
supervised by David Delahaye, Damien Doligez and Olivier Hermant.</p>
          </li>
          <li id="uid146">
            <p noindent="true">PhD:
Jacques-Henri Jourdan,
“Verasco: a formally verified C static analyzer” <ref xlink:href="#gallium-2016-bid13" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>,
Université Paris Diderot,
defended May 2016,
supervised by Xavier Leroy.</p>
          </li>
          <li id="uid147">
            <p noindent="true">PhD:
Gabriel Scherer,
“Which types have a unique inhabitant?” <ref xlink:href="#gallium-2016-bid16" location="biblio" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>,
Université Paris Diderot,
defended March 2016,
supervised by Didier Rémy.</p>
          </li>
          <li id="uid148">
            <p noindent="true">PhD in progress:
Vitalii Aksenov,
“Parallel Dynamic Algorithms”,
Université Paris Diderot,
since September 2015,
supervised by Umut Acar
(co-advised with Anatoly Shalyto, ITMO University of Saint Petersburg, Russia).</p>
          </li>
          <li id="uid149">
            <p noindent="true">PhD in progress: Thomas Blanc (ENSTA-ParisTech &amp; OCamlPro),
“Analyses de programmes complets, application à OCaml”,
Université Paris-Saclay,
since February 2014,
supervised by Michel Mauny and Pierre Chambart (OCamlPro).</p>
          </li>
          <li id="uid150">
            <p noindent="true">PhD in progress: Pierrick Couderc (ENSTA-ParisTech &amp; OCamlPro),
“Typage modulaire du langage intermédiaire du compilateur OCaml,”
Université Paris-Saclay,
since December 2014,
supervised by Michel Mauny, Grégoire Henry (OCamlPro) and Fabrice Le Fessant.</p>
          </li>
          <li id="uid151">
            <p noindent="true">PhD in progress: Albin Coquereau (ENSTA-ParisTech),
“Amélioration de performances pour le solveur SMT Alt-Ergo: conception d'outils
d'analyse, optimisations et structures de données efficaces pour OCaml,”
Université Paris-Saclay,
since October 2015,
supervised by Michel Mauny, Sylvain Conchon (LRI, Université Paris-Sud) and Fabrice Le Fessant.</p>
          </li>
          <li id="uid152">
            <p noindent="true">PhD in progress:
Armaël Guéneau,
“Towards Machine-Checked Time Complexity Analyses”,
Université Paris Diderot,
since September 2016,
supervised by Arthur Charguéraud and François Pottier.</p>
          </li>
          <li id="uid153">
            <p noindent="true">PhD in progress:
Thomas Williams,
“Putting Ornaments into practice”,
Université Paris Diderot,
since September 2014,
supervised by Didier Rémy.</p>
          </li>
        </sanspuceslist>
      </subsection>
      <subsection id="uid154" level="2">
        <bodyTitle>Juries</bodyTitle>
        <p>François Pottier was a reviewer for the Ph.D. thesis of
Benoît Vaugon,
Université Paris-Saclay,
March 2016.
He was a reviewer for the Habilitation of
Damien Pous,
ENS Lyon,
September 2016.
He was a member of the jury for the Ph.D. thesis of
Léon Gondelman,
Université Paris-Saclay,
December 2016.</p>
        <p>Xavier Leroy was on the Ph.D. committee of
Pierre Wilke,
Université Rennes 1,
November 2016.</p>
        <p>Didier Rémy was chair of the Ph.D. committee of
Raphaël Cauderlier,
Conservatoire National des Arts et Métiers (CNAM),
October 2016.</p>
      </subsection>
    </subsection>
    <subsection id="uid155" level="1">
      <bodyTitle>Popularization</bodyTitle>
      <p>Xavier Leroy gave a popularization talk on formal methods at the
plenary days of Inria's DGD-T (may 2016) and another on critical
avionics software for first-year students at École Polytechnique (june
2016).</p>
    </subsection>
  </diffusion>
  <biblio id="bibliography" html="bibliography" numero="10" titre="Bibliography">
    
    <biblStruct id="gallium-2016-bid54" type="article" rend="refer" n="refercite:2014-Alglave-Maranget-Tautschnig">
      <identifiant type="doi" value="10.1145/2627752"/>
      <analytic>
        <title level="a">Herding cats: modelling, simulation, testing, and data-mining for weak memory</title>
        <author>
          <persName>
            <foreName>Jade</foreName>
            <surname>Alglave</surname>
            <initial>J.</initial>
          </persName>
          <persName key="gallium-2014-idp66296">
            <foreName>Luc</foreName>
            <surname>Maranget</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Michael</foreName>
            <surname>Tautschnig</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">ACM Transactions on Programming Languages and Systems</title>
        <imprint>
          <biblScope type="volume">36</biblScope>
          <biblScope type="number">2</biblScope>
          <dateStruct>
            <year>2014</year>
          </dateStruct>
          <biblScope type="pages">article no 7</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/2627752" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2627752</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid51" type="inproceedings" rend="refer" n="refercite:2010-Doligez-TLA+">
      <identifiant type="doi" value="10.1007/978-3-642-14203-1_12"/>
      <analytic>
        <title level="a">Verifying Safety Properties With the TLA+ Proof System</title>
        <author>
          <persName key="parsifal-2014-idp62456">
            <foreName>Kaustuv</foreName>
            <surname>Chaudhuri</surname>
            <initial>K.</initial>
          </persName>
          <persName key="gallium-2014-idm26976">
            <foreName>Damien</foreName>
            <surname>Doligez</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Leslie</foreName>
            <surname>Lamport</surname>
            <initial>L.</initial>
          </persName>
          <persName key="veridis-2014-idm26664">
            <foreName>Stephan</foreName>
            <surname>Merz</surname>
            <initial>S.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-international-audience="yes" x-proceedings="yes">
        <title level="m">Automated Reasoning, 5th International Joint Conference, IJCAR 2010</title>
        <title level="s">Lecture Notes in Computer Science</title>
        <imprint>
          <biblScope type="volume">6173</biblScope>
          <publisher>
            <orgName>Springer</orgName>
          </publisher>
          <dateStruct>
            <year>2010</year>
          </dateStruct>
          <biblScope type="pages">142–148</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1007/978-3-642-14203-1_12" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1007/<allowbreak/>978-3-642-14203-1_12</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid6" type="inproceedings" rend="refer" n="refercite:2014-Cretin-Remy">
      <identifiant type="doi" value="10.1145/2603088.2603128"/>
      <analytic>
        <title level="a">System F with Coercion Constraints</title>
        <author>
          <persName key="gallium-2014-idp79456">
            <foreName>Julien</foreName>
            <surname>Cretin</surname>
            <initial>J.</initial>
          </persName>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">CSL-LICS 2014: Computer Science Logic / Logic In Computer Science</title>
        <imprint>
          <publisher>
            <orgName>ACM</orgName>
          </publisher>
          <dateStruct>
            <year>2014</year>
          </dateStruct>
          <biblScope type="pages">article no 34</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/2603088.2603128" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2603088.<allowbreak/>2603128</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid55" type="inproceedings" rend="refer" n="refercite:jourdan:hal-01078386">
      <identifiant type="doi" value="10.1145/2676726.2676966"/>
      <analytic>
        <title level="a">A Formally-Verified C Static Analyzer</title>
        <author>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
          <persName key="celtique-2014-idp85344">
            <foreName>Vincent</foreName>
            <surname>Laporte</surname>
            <initial>V.</initial>
          </persName>
          <persName key="celtique-2014-idp67080">
            <foreName>Sandrine</foreName>
            <surname>Blazy</surname>
            <initial>S.</initial>
          </persName>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
          <persName key="celtique-2014-idp73952">
            <foreName>David</foreName>
            <surname>Pichardie</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">POPL'15: 42nd ACM Symposium on Principles of Programming Languages</title>
        <imprint>
          <publisher>
            <orgName>ACM Press</orgName>
          </publisher>
          <dateStruct>
            <month>January</month>
            <year>2015</year>
          </dateStruct>
          <biblScope type="pages">247-259</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/2676726.2676966" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2676726.<allowbreak/>2676966</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid50" type="article" rend="refer" n="refercite:2009-LeBotlan-Remy-recasting-mlf">
      <identifiant type="doi" value="10.1016/j.ic.2008.12.006"/>
      <analytic>
        <title level="a">Recasting MLF</title>
        <author>
          <persName>
            <foreName>Didier</foreName>
            <surname>Le Botlan</surname>
            <initial>D.</initial>
          </persName>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-editorial-board="yes" x-international-audience="yes">
        <title level="j">Information and Computation</title>
        <imprint>
          <biblScope type="volume">207</biblScope>
          <biblScope type="number">6</biblScope>
          <dateStruct>
            <year>2009</year>
          </dateStruct>
          <biblScope type="pages">726–785</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1016/j.ic.2008.12.006" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1016/<allowbreak/>j.<allowbreak/>ic.<allowbreak/>2008.<allowbreak/>12.<allowbreak/>006</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid11" type="article" rend="refer" n="refercite:2009-Leroy-Compcert-backend">
      <identifiant type="doi" value="10.1007/s10817-009-9155-4"/>
      <analytic>
        <title level="a">A formally verified compiler back-end</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-editorial-board="yes" x-international-audience="yes">
        <title level="j">Journal of Automated Reasoning</title>
        <imprint>
          <biblScope type="volume">43</biblScope>
          <biblScope type="number">4</biblScope>
          <dateStruct>
            <year>2009</year>
          </dateStruct>
          <biblScope type="pages">363–446</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1007/s10817-009-9155-4" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1007/<allowbreak/>s10817-009-9155-4</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid10" type="article" rend="refer" n="refercite:2009-Leroy-Compcert-CACM">
      <identifiant type="doi" value="10.1145/1538788.1538814"/>
      <analytic>
        <title level="a">Formal verification of a realistic compiler</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-editorial-board="yes" x-international-audience="yes">
        <title level="j">Communications of the ACM</title>
        <imprint>
          <biblScope type="volume">52</biblScope>
          <biblScope type="number">7</biblScope>
          <dateStruct>
            <year>2009</year>
          </dateStruct>
          <biblScope type="pages">107–115</biblScope>
          <ref xlink:href="http://doi.acm.org/10.1145/1538788.1538814" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>doi.<allowbreak/>acm.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>1538788.<allowbreak/>1538814</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid49" type="inproceedings" rend="refer" n="refercite:2008-Pottier-antiframe">
      <identifiant type="doi" value="10.1109/LICS.2008.16"/>
      <analytic>
        <title level="a">Hiding local state in direct style: a higher-order anti-frame rule</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-international-audience="yes" x-proceedings="yes">
        <title level="m">Proceedings of the 23rd Annual IEEE Symposium on Logic In Computer Science (LICS'08)</title>
        <imprint>
          <publisher>
            <orgName>IEEE Computer Society Press</orgName>
          </publisher>
          <dateStruct>
            <month>June</month>
            <year>2008</year>
          </dateStruct>
          <biblScope type="pages">331-340</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1109/LICS.2008.16" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1109/<allowbreak/>LICS.<allowbreak/>2008.<allowbreak/>16</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid53" type="inproceedings" rend="refer" n="refercite:2013-Pottier-Protzenko">
      <identifiant type="doi" value="10.1145/2500365.2500598"/>
      <analytic>
        <title level="a">Programming with permissions in Mezzo</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
          <persName key="gallium-2014-idp83264">
            <foreName>Jonathan</foreName>
            <surname>Protzenko</surname>
            <initial>J.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-international-audience="yes" x-proceedings="yes">
        <title level="m">Proceedings of the 18th International Conference on Functional Programming (ICFP 2013)</title>
        <imprint>
          <publisher>
            <orgName>ACM Press</orgName>
          </publisher>
          <dateStruct>
            <year>2013</year>
          </dateStruct>
          <biblScope type="pages">173–184</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/2500365.2500598" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2500365.<allowbreak/>2500598</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid52" type="article" rend="refer" n="refercite:2012-Pouillard-Pottier">
      <identifiant type="doi" value="10.1017/S0956796812000251"/>
      <analytic>
        <title level="a">A unified treatment of syntax with binders</title>
        <author>
          <persName>
            <foreName>Nicolas</foreName>
            <surname>Pouillard</surname>
            <initial>N.</initial>
          </persName>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-editorial-board="yes" x-international-audience="yes">
        <title level="j">Journal of Functional Programming</title>
        <imprint>
          <biblScope type="volume">22</biblScope>
          <biblScope type="number">4–5</biblScope>
          <dateStruct>
            <year>2012</year>
          </dateStruct>
          <biblScope type="pages">614–704</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1017/S0956796812000251" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1017/<allowbreak/>S0956796812000251</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid13" type="phdthesis" rend="year" n="cite:jourdan:tel-01327023">
      <identifiant type="hal" value="tel-01327023"/>
      <monogr>
        <title level="m">Verasco: a Formally Verified C Static Analyzer</title>
        <author>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="school">Universite Paris Diderot-Paris VII</orgName>
          </publisher>
          <dateStruct>
            <month>May</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.archives-ouvertes.fr/tel-01327023" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>archives-ouvertes.<allowbreak/>fr/<allowbreak/>tel-01327023</ref>
        </imprint>
      </monogr>
      <note type="typdoc">Theses</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid16" type="phdthesis" rend="year" n="cite:scherer:tel-01309712">
      <identifiant type="hal" value="tel-01309712"/>
      <monogr>
        <title level="m">Which types have a unique inhabitant?: Focusing on pure program equivalence</title>
        <author>
          <persName key="gallium-2014-idp84504">
            <foreName>Gabriel</foreName>
            <surname>Scherer</surname>
            <initial>G.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="school">Université Paris-Diderot</orgName>
          </publisher>
          <dateStruct>
            <month>March</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/tel-01309712" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>tel-01309712</ref>
        </imprint>
      </monogr>
      <note type="typdoc">Theses</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid21" type="article" rend="year" n="cite:acar:hal-01409069">
      <identifiant type="doi" value="10.1017/S0956796816000101"/>
      <identifiant type="hal" value="hal-01409069"/>
      <analytic>
        <title level="a">Oracle-Guided Scheduling for Controlling Granularity in Implicitly Parallel Languages</title>
        <author>
          <persName key="gallium-2014-idm28256">
            <foreName>Umut A</foreName>
            <surname>Acar</surname>
            <initial>U. A.</initial>
          </persName>
          <persName key="toccata-2014-idp68328">
            <foreName>Arthur</foreName>
            <surname>Charguéraud</surname>
            <initial>A.</initial>
          </persName>
          <persName key="gallium-2014-idp68976">
            <foreName>Mike</foreName>
            <surname>Rainey</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid01146">
        <idno type="issn">0956-7968</idno>
        <title level="j">Journal of Functional Programming</title>
        <imprint>
          <biblScope type="volume">26</biblScope>
          <dateStruct>
            <month>November</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01409069" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01409069</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid38" type="article" rend="year" n="cite:balabonski:hal-01246534">
      <identifiant type="doi" value="10.1145/2837022"/>
      <identifiant type="hal" value="hal-01246534"/>
      <analytic>
        <title level="a">The Design and Formalization of Mezzo, a Permission-Based Programming Language</title>
        <author>
          <persName key="gallium-2014-idp73048">
            <foreName>Thibaut</foreName>
            <surname>Balabonski</surname>
            <initial>T.</initial>
          </persName>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
          <persName key="gallium-2014-idp83264">
            <foreName>Jonathan</foreName>
            <surname>Protzenko</surname>
            <initial>J.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid00032">
        <idno type="issn">0164-0925</idno>
        <title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
        <imprint>
          <biblScope type="volume">38</biblScope>
          <biblScope type="number">4</biblScope>
          <dateStruct>
            <month>August</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">94</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01246534" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01246534</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid48" type="article" rend="year" n="cite:riviere:hal-01297367">
      <identifiant type="doi" value="10.1016/j.cmpb.2015.10.018"/>
      <identifiant type="hal" value="hal-01297367"/>
      <analytic>
        <title level="a">dfcomb: An R-package for phase I/II trials of drug combinations</title>
        <author>
          <persName>
            <foreName>Marie-Karelle</foreName>
            <surname>Riviere</surname>
            <initial>M.-K.</initial>
          </persName>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
          <persName>
            <foreName>Sarah</foreName>
            <surname>Zohar</surname>
            <initial>S.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid00396">
        <idno type="issn">0169-2607</idno>
        <title level="j">Computer Methods and Programs in Biomedicine</title>
        <imprint>
          <biblScope type="volume">125</biblScope>
          <dateStruct>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">117–133</biblScope>
          <ref xlink:href="http://hal.upmc.fr/hal-01297367" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01297367</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid47" type="article" rend="year" n="cite:riviere:hal-01298681">
      <identifiant type="doi" value="10.1177/0962280216631763"/>
      <identifiant type="hal" value="hal-01298681"/>
      <analytic>
        <title level="a">Phase I/II dose-finding design for molecularly targeted agent: Plateau determination using adaptive randomization</title>
        <author>
          <persName>
            <foreName>Marie-Karelle</foreName>
            <surname>Riviere</surname>
            <initial>M.-K.</initial>
          </persName>
          <persName>
            <foreName>Ying</foreName>
            <surname>Yuan</surname>
            <initial>Y.</initial>
          </persName>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
          <persName>
            <foreName>Frédéric</foreName>
            <surname>Dubois</surname>
            <initial>F.</initial>
          </persName>
          <persName>
            <foreName>Sarah</foreName>
            <surname>Zohar</surname>
            <initial>S.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-editorial-board="yes" x-international-audience="yes" id="rid03099">
        <idno type="issn">0962-2802</idno>
        <title level="j">Statistical Methods in Medical Research</title>
        <imprint>
          <dateStruct>
            <month>March</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="http://hal.upmc.fr/hal-01298681" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01298681</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid20" type="inproceedings" rend="year" n="cite:acar:hal-01416531">
      <identifiant type="doi" value="10.1145/3018743.3018762"/>
      <identifiant type="hal" value="hal-01416531"/>
      <analytic>
        <title level="a">Contention in Structured Concurrency: Provably Efficient Dynamic Non-Zero Indicators for Nested Parallelism</title>
        <author>
          <persName key="gallium-2014-idm28256">
            <foreName>Umut A</foreName>
            <surname>Acar</surname>
            <initial>U. A.</initial>
          </persName>
          <persName>
            <foreName>Naama</foreName>
            <surname>Ben-David</surname>
            <initial>N.</initial>
          </persName>
          <persName key="gallium-2014-idp68976">
            <foreName>Mike</foreName>
            <surname>Rainey</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">22nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
        <loc>Austin, United States</loc>
        <imprint>
          <dateStruct>
            <month>February</month>
            <year>2017</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01416531" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01416531</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>44</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid18" type="inproceedings" rend="year" n="cite:acar:hal-01409022">
      <identifiant type="doi" value="10.1145/2951913.2951946"/>
      <identifiant type="hal" value="hal-01409022"/>
      <analytic>
        <title level="a">Dag-calculus: a calculus for parallel computation</title>
        <author>
          <persName key="gallium-2014-idm28256">
            <foreName>Umut A</foreName>
            <surname>Acar</surname>
            <initial>U. A.</initial>
          </persName>
          <persName key="toccata-2014-idp68328">
            <foreName>Arthur</foreName>
            <surname>Charguéraud</surname>
            <initial>A.</initial>
          </persName>
          <persName key="gallium-2014-idp68976">
            <foreName>Mike</foreName>
            <surname>Rainey</surname>
            <initial>M.</initial>
          </persName>
          <persName key="gallium-2015-idp79904">
            <foreName>Filip</foreName>
            <surname>Sieczkowski</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming (ICFP)</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">18 - 32</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01409022" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01409022</ref>
        </imprint>
        <meeting id="cid21926">
          <title>ACM SIGPLAN International Conference on Functional Programming</title>
          <num>21</num>
          <abbr type="sigle">ICFP</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid43" type="inproceedings" rend="year" n="cite:ahman:hal-01424794">
      <identifiant type="hal" value="hal-01424794"/>
      <analytic>
        <title level="a">Dijkstra Monads for Free</title>
        <author>
          <persName>
            <foreName>Danel</foreName>
            <surname>Ahman</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Cătălin</foreName>
            <surname>Hriţcu</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Kenji</foreName>
            <surname>Maillard</surname>
            <initial>K.</initial>
          </persName>
          <persName key="prosecco-2016-idp189520">
            <foreName>Guido</foreName>
            <surname>Martínez</surname>
            <initial>G.</initial>
          </persName>
          <persName>
            <foreName>Gordon</foreName>
            <surname>Plotkin</surname>
            <initial>G.</initial>
          </persName>
          <persName key="gallium-2014-idp83264">
            <foreName>Jonathan</foreName>
            <surname>Protzenko</surname>
            <initial>J.</initial>
          </persName>
          <persName>
            <foreName>Aseem</foreName>
            <surname>Rastogi</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Nikhil</foreName>
            <surname>Swamy</surname>
            <initial>N.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL)</title>
        <loc>Unknown, Unknown or Invalid Region</loc>
        <imprint>
          <publisher>
            <orgName>ACM</orgName>
          </publisher>
          <dateStruct>
            <year>2017</year>
          </dateStruct>
          <biblScope type="pages">515-529</biblScope>
          <ref xlink:href="https://hal.archives-ouvertes.fr/hal-01424794" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>archives-ouvertes.<allowbreak/>fr/<allowbreak/>hal-01424794</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>44</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid45" type="inproceedings" rend="year" n="cite:azaiez:hal-01322335">
      <identifiant type="doi" value="10.1007/978-3-319-33600-8_4"/>
      <identifiant type="hal" value="hal-01322335"/>
      <analytic>
        <title level="a">Proving Determinacy of the PharOS Real-Time Operating System</title>
        <author>
          <persName>
            <foreName>Selma</foreName>
            <surname>Azaiez</surname>
            <initial>S.</initial>
          </persName>
          <persName key="gallium-2014-idm26976">
            <foreName>Damien</foreName>
            <surname>Doligez</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Matthieu</foreName>
            <surname>Lemerre</surname>
            <initial>M.</initial>
          </persName>
          <persName key="parsifal-2015-idp71224">
            <foreName>Tomer</foreName>
            <surname>Libal</surname>
            <initial>T.</initial>
          </persName>
          <persName key="veridis-2014-idm26664">
            <foreName>Stephan</foreName>
            <surname>Merz</surname>
            <initial>S.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <editor role="editor">
          <persName>
            <foreName>Michael J.</foreName>
            <surname>Butler</surname>
            <initial>M. J.</initial>
          </persName>
          <persName>
            <foreName>Klaus-Dieter</foreName>
            <surname>Schewe</surname>
            <initial>K.-D.</initial>
          </persName>
          <persName>
            <foreName>Atif</foreName>
            <surname>Mashkoor</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Miklós</foreName>
            <surname>Biró</surname>
            <initial>M.</initial>
          </persName>
        </editor>
        <title level="m">Abstract State Machines, Alloy, B, TLA, VDM, and Z - 5th International Conference, ABZ 2016</title>
        <loc>Linz, Austria</loc>
        <title level="s">LNCS - Lecture Notes in Computer Science</title>
        <imprint>
          <biblScope type="volume">9675</biblScope>
          <publisher>
            <orgName>Springer</orgName>
          </publisher>
          <dateStruct>
            <month>May</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">70-85</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01322335" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01322335</ref>
        </imprint>
        <meeting id="cid387338">
          <title>Abstract State Machines, Alloy, B and Z</title>
          <num>5</num>
          <abbr type="sigle">ABZ</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid23" type="inproceedings" rend="year" n="cite:balestrieri:hal-01413061">
      <identifiant type="hal" value="hal-01413061"/>
      <analytic>
        <title level="a">Generic Programming in OCaml</title>
        <author>
          <persName>
            <foreName>Florent</foreName>
            <surname>Balestrieri</surname>
            <initial>F.</initial>
          </persName>
          <persName key="gallium-2016-idp121360">
            <foreName>Michel</foreName>
            <surname>Mauny</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml 2016 - The OCaml Users and Developers Workshop</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01413061" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01413061</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid46" type="inproceedings" rend="year" n="cite:bozman:hal-01352013">
      <identifiant type="hal" value="hal-01352013"/>
      <analytic>
        <title level="a">ocp-lint, A Plugin-based Style-Checker with Semantic Patches</title>
        <author>
          <persName>
            <foreName>Çagdas</foreName>
            <surname>Bozman</surname>
            <initial>Ç.</initial>
          </persName>
          <persName>
            <foreName>Théophane</foreName>
            <surname>Huffschmitt</surname>
            <initial>T.</initial>
          </persName>
          <persName key="gallium-2014-idp87016">
            <foreName>Michael</foreName>
            <surname>Laporte</surname>
            <initial>M.</initial>
          </persName>
          <persName key="gallium-2014-idm25696">
            <foreName>Fabrice</foreName>
            <surname>Le Fessant</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml Users and Developers Workshop 2016</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01352013" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01352013</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid33" type="inproceedings" rend="year" n="cite:canou:hal-01352015">
      <identifiant type="hal" value="hal-01352015"/>
      <analytic>
        <title level="a">Learn OCaml, An Online Learning Center for OCaml</title>
        <author>
          <persName>
            <foreName>Benjamin</foreName>
            <surname>Canou</surname>
            <initial>B.</initial>
          </persName>
          <persName>
            <foreName>Grégoire</foreName>
            <surname>Henry</surname>
            <initial>G.</initial>
          </persName>
          <persName>
            <foreName>Çagdas</foreName>
            <surname>Bozman</surname>
            <initial>Ç.</initial>
          </persName>
          <persName key="gallium-2014-idm25696">
            <foreName>Fabrice</foreName>
            <surname>Le Fessant</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml Users and Developers Workshop 2016</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01352015" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01352015</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid31" type="inproceedings" rend="year" n="cite:courtieu:hal-01349061">
      <identifiant type="hal" value="hal-01349061"/>
      <analytic>
        <title level="a">A Certified Universal Gathering Algorithm for Oblivious Mobile Robots</title>
        <author>
          <persName key="gallium-2014-idp71704">
            <foreName>Pierre</foreName>
            <surname>Courtieu</surname>
            <initial>P.</initial>
          </persName>
          <persName>
            <foreName>Lionel</foreName>
            <surname>Rieg</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Sébastien</foreName>
            <surname>Tixeuil</surname>
            <initial>S.</initial>
          </persName>
          <persName key="toccata-2014-idp104368">
            <foreName>Xavier</foreName>
            <surname>Urbain</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Distributed Computing (DISC)</title>
        <loc>Paris, France</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="http://hal.upmc.fr/hal-01349061" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01349061</ref>
        </imprint>
        <meeting id="cid313621">
          <title>International Symposium on Distributed Computing</title>
          <num>30</num>
          <abbr type="sigle">DISC</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid32" type="inproceedings" rend="year" n="cite:courtieu:hal-01349084">
      <identifiant type="hal" value="hal-01349084"/>
      <analytic>
        <title level="a">Certified Universal Gathering in R2 for Oblivious Mobile Robots</title>
        <author>
          <persName key="gallium-2014-idp71704">
            <foreName>Pierre</foreName>
            <surname>Courtieu</surname>
            <initial>P.</initial>
          </persName>
          <persName>
            <foreName>Lionel</foreName>
            <surname>Rieg</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Sébastien</foreName>
            <surname>Tixeuil</surname>
            <initial>S.</initial>
          </persName>
          <persName key="toccata-2014-idp104368">
            <foreName>Xavier</foreName>
            <surname>Urbain</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">ACM Conference on Principles of Distributed Computing (PODC)</title>
        <loc>Chicago, United States</loc>
        <imprint>
          <publisher>
            <orgName type="organisation">ACM</orgName>
          </publisher>
          <dateStruct>
            <month>July</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="http://hal.upmc.fr/hal-01349084" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>hal.<allowbreak/>upmc.<allowbreak/>fr/<allowbreak/>hal-01349084</ref>
        </imprint>
        <meeting id="cid24682">
          <title>ACM Symposium on Principles of Distributed Computing</title>
          <num>35</num>
          <abbr type="sigle">PODC</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid35" type="inproceedings" rend="year" n="cite:flur:hal-01244776">
      <identifiant type="hal" value="hal-01244776"/>
      <analytic>
        <title level="a">Modelling the ARMv8 Architecture, Operationally: Concurrency and ISA</title>
        <author>
          <persName>
            <foreName>Shaked</foreName>
            <surname>Flur</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Kathryn E.</foreName>
            <surname>Gray</surname>
            <initial>K. E.</initial>
          </persName>
          <persName>
            <foreName>Christopher</foreName>
            <surname>Pulte</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Susmit</foreName>
            <surname>Sarkar</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Ali</foreName>
            <surname>Sezgin</surname>
            <initial>A.</initial>
          </persName>
          <persName key="gallium-2014-idp66296">
            <foreName>Luc</foreName>
            <surname>Maranget</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Will</foreName>
            <surname>Deacon</surname>
            <initial>W.</initial>
          </persName>
          <persName>
            <foreName>Peter</foreName>
            <surname>Sewell</surname>
            <initial>P.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Principles of Programming Languages 2016 (POPL 2016)</title>
        <loc>Saint Petersburg, United States</loc>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01244776" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01244776</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>43</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid17" type="inproceedings" rend="year" n="cite:flur:hal-01413221">
      <identifiant type="hal" value="hal-01413221"/>
      <analytic>
        <title level="a">Mixed-size Concurrency: ARM, POWER, C/C++11, and SC</title>
        <author>
          <persName>
            <foreName>Shaked</foreName>
            <surname>Flur</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Susmit</foreName>
            <surname>Sarkar</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Christopher</foreName>
            <surname>Pulte</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Kyndylan</foreName>
            <surname>Nienhuis</surname>
            <initial>K.</initial>
          </persName>
          <persName key="gallium-2014-idp66296">
            <foreName>Luc</foreName>
            <surname>Maranget</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Kathryn E.</foreName>
            <surname>Gray</surname>
            <initial>K. E.</initial>
          </persName>
          <persName>
            <foreName>Ali</foreName>
            <surname>Sezgin</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Mark</foreName>
            <surname>Batty</surname>
            <initial>M.</initial>
          </persName>
          <persName>
            <foreName>Peter</foreName>
            <surname>Sewell</surname>
            <initial>P.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL 2017)</title>
        <loc>Paris, France</loc>
        <imprint>
          <publisher>
            <orgName type="organisation">ACM</orgName>
          </publisher>
          <dateStruct>
            <month>January</month>
            <year>2017</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01413221" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01413221</ref>
        </imprint>
        <meeting id="cid22344">
          <title>ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages</title>
          <num>44</num>
          <abbr type="sigle">POPL</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid14" type="inproceedings" rend="year" n="cite:jourdan:hal-01406795">
      <identifiant type="hal" value="hal-01406795"/>
      <analytic>
        <title level="a">Sparsity Preserving Algorithms for Octagons</title>
        <author>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <editor role="editor">
          <persName>
            <foreName>Isabella</foreName>
            <surname>Mastroeni</surname>
            <initial>I.</initial>
          </persName>
        </editor>
        <title level="m">NSAD 2016 - Numerical and symbolic abstract domains workshop</title>
        <loc>Edinburgh, United Kingdom</loc>
        <imprint>
          <publisher>
            <orgName>Elsevier</orgName>
          </publisher>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">14</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01406795" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01406795</ref>
        </imprint>
        <meeting id="cid387170">
          <title>International Workshop on Numerical And Symbolic Abstract Domains</title>
          <num>2016</num>
          <abbr type="sigle">NSAD</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid36" type="inproceedings" rend="year" n="cite:jourdan:hal-01406809">
      <identifiant type="hal" value="hal-01406809"/>
      <analytic>
        <title level="a">Statistically profiling memory in OCaml</title>
        <author>
          <persName key="gallium-2014-idp82000">
            <foreName>Jacques-Henri</foreName>
            <surname>Jourdan</surname>
            <initial>J.-H.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml 2016</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01406809" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01406809</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid44" type="inproceedings" rend="year" n="cite:kastner:hal-01399482">
      <identifiant type="hal" value="hal-01399482"/>
      <analytic>
        <title level="a">Closing the Gap – The Formally Verified Optimizing Compiler CompCert</title>
        <author>
          <persName>
            <foreName>Daniel</foreName>
            <surname>Kästner</surname>
            <initial>D.</initial>
          </persName>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
          <persName key="celtique-2014-idp67080">
            <foreName>Sandrine</foreName>
            <surname>Blazy</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Bernhard</foreName>
            <surname>Schommer</surname>
            <initial>B.</initial>
          </persName>
          <persName>
            <foreName>Michael</foreName>
            <surname>Schmidt</surname>
            <initial>M.</initial>
          </persName>
          <persName>
            <foreName>Christian</foreName>
            <surname>Ferdinand</surname>
            <initial>C.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">SSS'17: Safety-critical Systems Symposium 2017</title>
        <loc>Bristol, United Kingdom</loc>
        <title level="s">Proceedings of the Twenty-fifth Safety-Critical Systems Symposium</title>
        <imprint>
          <dateStruct>
            <month>February</month>
            <year>2017</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01399482" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01399482</ref>
        </imprint>
        <meeting id="cid625443">
          <title>Safety-critical Systems Symposium</title>
          <num>2017</num>
          <abbr type="sigle">SSS</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid22" type="inproceedings" rend="year" n="cite:lefessant:hal-01352008">
      <identifiant type="hal" value="hal-01352008"/>
      <analytic>
        <title level="a">OPAM-builder: Continuous Monitoring of OPAM Repositories</title>
        <author>
          <persName key="gallium-2014-idm25696">
            <foreName>Fabrice</foreName>
            <surname>Le Fessant</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml Users and Developers Workshop 2016</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01352008" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01352008</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid37" type="inproceedings" rend="year" n="cite:leroy:hal-01238879">
      <identifiant type="hal" value="hal-01238879"/>
      <analytic>
        <title level="a">CompCert - A Formally Verified Optimizing Compiler</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
          <persName key="celtique-2014-idp67080">
            <foreName>Sandrine</foreName>
            <surname>Blazy</surname>
            <initial>S.</initial>
          </persName>
          <persName>
            <foreName>Daniel</foreName>
            <surname>Kästner</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Bernhard</foreName>
            <surname>Schommer</surname>
            <initial>B.</initial>
          </persName>
          <persName>
            <foreName>Markus</foreName>
            <surname>Pister</surname>
            <initial>M.</initial>
          </persName>
          <persName>
            <foreName>Christian</foreName>
            <surname>Ferdinand</surname>
            <initial>C.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">ERTS 2016: Embedded Real Time Software and Systems, 8th European Congress</title>
        <loc>Toulouse, France</loc>
        <imprint>
          <publisher>
            <orgName type="organisation">SEE</orgName>
          </publisher>
          <dateStruct>
            <month>January</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01238879" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01238879</ref>
        </imprint>
        <meeting id="cid68744">
          <title>European Congress on Embedded Real Time Software</title>
          <num>8</num>
          <abbr type="sigle">ERTS</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid25" type="inproceedings" rend="year" n="cite:pottier:hal-01248101">
      <identifiant type="hal" value="hal-01248101"/>
      <analytic>
        <title level="a">Reachability and error diagnosis in LR(1) automata</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="no" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Journées Francophones des Langages Applicatifs</title>
        <loc>Saint-Malo, France</loc>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01248101" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01248101</ref>
        </imprint>
        <meeting id="cid344980">
          <title>Journées Francophones des Langages Applicatifs</title>
          <num>19</num>
          <abbr type="sigle">JFLA</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid26" type="inproceedings" rend="year" n="cite:pottier:hal-01417004">
      <identifiant type="doi" value="10.1145/2892208.2892224"/>
      <identifiant type="hal" value="hal-01417004"/>
      <analytic>
        <title level="a">Reachability and Error Diagnosis in LR(1) Parsers</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">CC 2016 - 25th International Conference on Compiler Construction</title>
        <loc>Barcelone, Spain</loc>
        <title level="s">Proceedings of the 25th International Conference on Compiler Construction (CC 2016)</title>
        <imprint>
          <dateStruct>
            <month>March</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">11</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01417004" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01417004</ref>
        </imprint>
        <meeting id="cid114893">
          <title>International Conference on Compiler Construction</title>
          <num>25</num>
          <abbr type="sigle">CC</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid29" type="inproceedings" rend="year" n="cite:pottier:hal-01417102">
      <identifiant type="hal" value="hal-01417102"/>
      <analytic>
        <title level="a">Verifying a Hash Table and Its Iterators in Higher-Order Separation Logic</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Certified Programs and Proofs</title>
        <loc>Paris, France</loc>
        <title level="s">Proceedings of the 6th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2017)</title>
        <imprint>
          <dateStruct>
            <month>January</month>
            <year>2017</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01417102" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01417102</ref>
        </imprint>
        <meeting id="cid196878">
          <title>International Conference on Certified Programs and Proofs</title>
          <num>1</num>
          <abbr type="sigle">CPP</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid39" type="inproceedings" rend="year" n="cite:raghunathan:hal-01416237">
      <identifiant type="doi" value="10.1145/3022670.2951935"/>
      <identifiant type="hal" value="hal-01416237"/>
      <analytic>
        <title level="a">Hierarchical Memory Management for Parallel Programs</title>
        <author>
          <persName>
            <foreName>Ram A</foreName>
            <surname>Raghunathan</surname>
            <initial>R. A.</initial>
          </persName>
          <persName>
            <foreName>Stefan A</foreName>
            <surname>Muller</surname>
            <initial>S. A.</initial>
          </persName>
          <persName key="gallium-2014-idm28256">
            <foreName>Umut A</foreName>
            <surname>Acar</surname>
            <initial>U. A.</initial>
          </persName>
          <persName>
            <foreName>Guy A</foreName>
            <surname>Blelloch</surname>
            <initial>G. A.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01416237" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01416237</ref>
        </imprint>
        <meeting id="cid21926">
          <title>ACM SIGPLAN International Conference on Functional Programming</title>
          <num>21</num>
          <abbr type="sigle">ICFP</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid24" type="inproceedings" rend="year" n="cite:scherer:hal-01413241">
      <identifiant type="hal" value="hal-01413241"/>
      <analytic>
        <title level="a">Ambiguous pattern variables</title>
        <author>
          <persName key="gallium-2014-idp84504">
            <foreName>Gabriel</foreName>
            <surname>Scherer</surname>
            <initial>G.</initial>
          </persName>
          <persName key="gallium-2014-idp66296">
            <foreName>Luc</foreName>
            <surname>Maranget</surname>
            <initial>L.</initial>
          </persName>
          <persName>
            <foreName>Thomas</foreName>
            <surname>Réfis</surname>
            <initial>T.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="no" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">OCaml 2016: The OCaml Users and Developers Workshop</title>
        <loc>Nara, Japan</loc>
        <imprint>
          <dateStruct>
            <month>September</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">2</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01413241" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01413241</ref>
        </imprint>
        <meeting id="cid624705">
          <title>OCaml Users and Developers Workshop</title>
          <num>2016</num>
          <abbr type="sigle">OCaml</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid27" type="inproceedings" rend="year" n="cite:svendsen:hal-01408649">
      <identifiant type="doi" value="10.1007/978-3-662-49498-1_28"/>
      <identifiant type="hal" value="hal-01408649"/>
      <analytic>
        <title level="a">Transfinite Step-Indexing: Decoupling Concrete and Logical Steps</title>
        <author>
          <persName>
            <foreName>Kasper</foreName>
            <surname>Svendsen</surname>
            <initial>K.</initial>
          </persName>
          <persName key="gallium-2015-idp79904">
            <foreName>Filip</foreName>
            <surname>Sieczkowski</surname>
            <initial>F.</initial>
          </persName>
          <persName>
            <foreName>Lars</foreName>
            <surname>Birkedal</surname>
            <initial>L.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">25th European Symposium on Programming Languages and Systems</title>
        <loc>Eindhoven, Netherlands</loc>
        <imprint>
          <biblScope type="volume">9632</biblScope>
          <dateStruct>
            <month>December</month>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">727 - 751</biblScope>
          <ref xlink:href="https://hal.inria.fr/hal-01408649" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01408649</ref>
        </imprint>
        <meeting id="cid71137">
          <title>European Symposium on Programming and Systems</title>
          <num>25</num>
          <abbr type="sigle">ESOP</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid40" type="inproceedings" rend="year" n="cite:vaugon:hal-01413043">
      <identifiant type="hal" value="hal-01413043"/>
      <analytic>
        <title level="a">A Type Inference System Based on Saturation of Subtyping Constraints</title>
        <author>
          <persName>
            <foreName>Benoît</foreName>
            <surname>Vaugon</surname>
            <initial>B.</initial>
          </persName>
          <persName key="gallium-2016-idp121360">
            <foreName>Michel</foreName>
            <surname>Mauny</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr x-scientific-popularization="no" x-international-audience="yes" x-proceedings="yes" x-invited-conference="no" x-editorial-board="yes">
        <title level="m">Trends in Functional Programming</title>
        <loc>College Park (MD), United States</loc>
        <imprint>
          <dateStruct>
            <month>June</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01413043" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01413043</ref>
        </imprint>
        <meeting id="cid365808">
          <title>Symposium on Trends in Functional Programming</title>
          <num>9</num>
          <abbr type="sigle">TFP</abbr>
        </meeting>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid42" type="techreport" rend="year" n="cite:leroy:hal-00930213">
      <identifiant type="hal" value="hal-00930213"/>
      <monogr>
        <title level="m">The OCaml system release 4.04: Documentation and user's manual</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
          <persName key="gallium-2014-idm26976">
            <foreName>Damien</foreName>
            <surname>Doligez</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Alain</foreName>
            <surname>Frisch</surname>
            <initial>A.</initial>
          </persName>
          <persName>
            <foreName>Jacques</foreName>
            <surname>Garrigue</surname>
            <initial>J.</initial>
          </persName>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Jérôme</foreName>
            <surname>Vouillon</surname>
            <initial>J.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="institution">Inria</orgName>
          </publisher>
          <dateStruct>
            <month>November</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-00930213" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-00930213</ref>
        </imprint>
      </monogr>
      <note type="typdoc">Intern report</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid41" type="techreport" rend="year" n="cite:leroy:hal-01091802">
      <identifiant type="hal" value="hal-01091802"/>
      <monogr>
        <title level="m">The CompCert C verified compiler: Documentation and user’s manual: Version 2.7</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="institution">Inria</orgName>
          </publisher>
          <dateStruct>
            <month>June</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01091802" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01091802</ref>
        </imprint>
      </monogr>
      <note type="typdoc">Intern report</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid30" type="unpublished" rend="year" n="cite:chargueraud:hal-01408657">
      <identifiant type="hal" value="hal-01408657"/>
      <monogr>
        <title level="m">Temporary Read-Only Permissions for Separation Logic</title>
        <author>
          <persName key="toccata-2014-idp68328">
            <foreName>Arthur</foreName>
            <surname>Charguéraud</surname>
            <initial>A.</initial>
          </persName>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
        <imprint>
          <dateStruct>
            <month>October</month>
            <year>2016</year>
          </dateStruct>
          <ref xlink:href="https://hal.inria.fr/hal-01408657" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>hal.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>hal-01408657</ref>
        </imprint>
      </monogr>
      <note type="bnote">working paper or preprint</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid3" type="inproceedings" rend="foot" n="footcite:2003-CDuce">
      <analytic>
        <title level="a">CDuce: an XML-centric general-purpose language</title>
        <author>
          <persName>
            <foreName>Véronique</foreName>
            <surname>Benzaken</surname>
            <initial>V.</initial>
          </persName>
          <persName>
            <foreName>Giuseppe</foreName>
            <surname>Castagna</surname>
            <initial>G.</initial>
          </persName>
          <persName>
            <foreName>Alain</foreName>
            <surname>Frisch</surname>
            <initial>A.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <editor role="editor">
          <persName>
            <foreName>Colin</foreName>
            <surname>Runciman</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Olin</foreName>
            <surname>Shivers</surname>
            <initial>O.</initial>
          </persName>
        </editor>
        <title level="m">Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming</title>
        <imprint>
          <publisher>
            <orgName>ACM</orgName>
          </publisher>
          <dateStruct>
            <year>2003</year>
          </dateStruct>
          <biblScope type="pages">51–63</biblScope>
          <ref xlink:href="https://www.lri.fr/~benzaken/papers/icfp03.ps" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://<allowbreak/>www.<allowbreak/>lri.<allowbreak/>fr/<allowbreak/>~benzaken/<allowbreak/>papers/<allowbreak/>icfp03.<allowbreak/>ps</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid19" type="inproceedings" rend="foot" n="footcite:2007-Ellen-Lev-Luchangco-Moir">
      <analytic>
        <title level="a">SNZI: Scalable NonZero Indicators</title>
        <author>
          <persName>
            <foreName>Faith</foreName>
            <surname>Ellen</surname>
            <initial>F.</initial>
          </persName>
          <persName>
            <foreName>Yossi</foreName>
            <surname>Lev</surname>
            <initial>Y.</initial>
          </persName>
          <persName>
            <foreName>Victor</foreName>
            <surname>Luchangco</surname>
            <initial>V.</initial>
          </persName>
          <persName>
            <foreName>Mark</foreName>
            <surname>Moir</surname>
            <initial>M.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">Proceedings of the Twenty-sixth Annual ACM Symposium on Principles of Distributed Computing</title>
        <imprint>
          <dateStruct>
            <year>2007</year>
          </dateStruct>
          <biblScope type="pages">13–22</biblScope>
          <ref xlink:href="http://dl.acm.org/citation.cfm?id=1281106" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dl.<allowbreak/>acm.<allowbreak/>org/<allowbreak/>citation.<allowbreak/>cfm?id=1281106</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid34" type="phdthesis" rend="foot" n="footcite:halmagrand2016phd">
      <monogr>
        <title level="m">Automated Deduction and Proof Certification for the B Method</title>
        <author>
          <persName key="deducteam-2014-idp106032">
            <foreName>Pierre</foreName>
            <surname>Halmagrand</surname>
            <initial>P.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="school">Conservatoire National des Arts et Métiers</orgName>
          </publisher>
          <dateStruct>
            <month>December</month>
            <year>2016</year>
          </dateStruct>
        </imprint>
      </monogr>
      <note type="typdoc">Ph. D. Thesis</note>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid2" type="article" rend="foot" n="footcite:2003-Hosoya-Pierce">
      <identifiant type="doi" value="10.1145/767193.767195"/>
      <analytic>
        <title level="a">XDuce: A Statically Typed XML Processing Language</title>
        <author>
          <persName>
            <foreName>Haruo</foreName>
            <surname>Hosoya</surname>
            <initial>H.</initial>
          </persName>
          <persName>
            <foreName>Benjamin C.</foreName>
            <surname>Pierce</surname>
            <initial>B. C.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">ACM Transactions on Internet Technology</title>
        <imprint>
          <biblScope type="volume">3</biblScope>
          <biblScope type="number">2</biblScope>
          <dateStruct>
            <year>2003</year>
          </dateStruct>
          <biblScope type="pages">117–148</biblScope>
          <ref xlink:href="http://doi.acm.org/10.1145/767193.767195" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>doi.<allowbreak/>acm.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>767193.<allowbreak/>767195</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid12" type="inproceedings" rend="foot" n="footcite:KangKHDV16">
      <identifiant type="doi" value="10.1145/2837614.2837642"/>
      <analytic>
        <title level="a">Lightweight verification of separate compilation</title>
        <author>
          <persName>
            <foreName>Jeehoon</foreName>
            <surname>Kang</surname>
            <initial>J.</initial>
          </persName>
          <persName>
            <foreName>Yoonseung</foreName>
            <surname>Kim</surname>
            <initial>Y.</initial>
          </persName>
          <persName>
            <foreName>Chung-Kil</foreName>
            <surname>Hur</surname>
            <initial>C.</initial>
          </persName>
          <persName>
            <foreName>Derek</foreName>
            <surname>Dreyer</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Viktor</foreName>
            <surname>Vafeiadis</surname>
            <initial>V.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
        <imprint>
          <dateStruct>
            <year>2016</year>
          </dateStruct>
          <biblScope type="pages">178–190</biblScope>
          <ref xlink:href="http://doi.acm.org/10.1145/2837614.2837642" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>doi.<allowbreak/>acm.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2837614.<allowbreak/>2837642</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid28" type="article" rend="foot" n="footcite:2012-lamport-proof">
      <identifiant type="doi" value="10.1007/s11784-012-0071-6"/>
      <analytic>
        <title level="a">How to write a 21st century proof</title>
        <author>
          <persName>
            <foreName>Leslie</foreName>
            <surname>Lamport</surname>
            <initial>L.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">Journal of Fixed Point Theory and Applications</title>
        <imprint>
          <biblScope type="volume">11</biblScope>
          <dateStruct>
            <year>2012</year>
          </dateStruct>
          <biblScope type="pages">43–63</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1007/s11784-012-0071-6" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1007/<allowbreak/>s11784-012-0071-6</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid0" type="manual" rend="foot" n="footcite:0000-Ocaml-manual">
      <monogr>
        <title level="m">The Objective Caml system, documentation and user's manual – release 4.02</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
          <persName key="gallium-2014-idm26976">
            <foreName>Damien</foreName>
            <surname>Doligez</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Jacques</foreName>
            <surname>Garrigue</surname>
            <initial>J.</initial>
          </persName>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Jérôme</foreName>
            <surname>Vouillon</surname>
            <initial>J.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName type="organisation">Inria</orgName>
          </publisher>
          <dateStruct>
            <month>August</month>
            <year>2014</year>
          </dateStruct>
          <ref xlink:href="http://caml.inria.fr/pub/docs/manual-ocaml-4.02/" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>caml.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>pub/<allowbreak/>docs/<allowbreak/>manual-ocaml-4.<allowbreak/>02/</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid7" type="article" rend="foot" n="footcite:2003-Leroy-JAR">
      <identifiant type="doi" value="10.1023/A:1025055424017"/>
      <analytic>
        <title level="a">Java bytecode verification: algorithms and formalizations</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">Journal of Automated Reasoning</title>
        <imprint>
          <biblScope type="volume">30</biblScope>
          <biblScope type="number">3–4</biblScope>
          <dateStruct>
            <year>2003</year>
          </dateStruct>
          <biblScope type="pages">235–269</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1023/A:1025055424017" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1023/<allowbreak/>A:1025055424017</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid9" type="inproceedings" rend="foot" n="footcite:2006-Leroy-compcert">
      <identifiant type="doi" value="10.1145/1111037.1111042"/>
      <analytic>
        <title level="a">Formal certification of a compiler back-end, or: programming a compiler with a proof assistant</title>
        <author>
          <persName key="gallium-2014-idm29528">
            <foreName>Xavier</foreName>
            <surname>Leroy</surname>
            <initial>X.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">33rd ACM symposium on Principles of Programming Languages</title>
        <imprint>
          <publisher>
            <orgName>ACM Press</orgName>
          </publisher>
          <dateStruct>
            <year>2006</year>
          </dateStruct>
          <biblScope type="pages">42–54</biblScope>
          <ref xlink:href="http://doi.acm.org/10.1145/1111037.1111042" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>doi.<allowbreak/>acm.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>1111037.<allowbreak/>1111042</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid1" type="book" rend="foot" n="footcite:TAPL">
      <monogr>
        <title level="m">Types and Programming Languages</title>
        <author>
          <persName>
            <foreName>Benjamin C.</foreName>
            <surname>Pierce</surname>
            <initial>B. C.</initial>
          </persName>
        </author>
        <imprint>
          <publisher>
            <orgName>MIT Press</orgName>
          </publisher>
          <dateStruct>
            <year>2002</year>
          </dateStruct>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid5" type="article" rend="foot" n="footcite:2001-Pottier-IC">
      <analytic>
        <title level="a">Simplifying subtyping constraints: a theory</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">Information and Computation</title>
        <imprint>
          <biblScope type="volume">170</biblScope>
          <biblScope type="number">2</biblScope>
          <dateStruct>
            <year>2001</year>
          </dateStruct>
          <biblScope type="pages">153–183</biblScope>
          <ref xlink:href="http://gallium.inria.fr/~fpottier/publis/fpottier-ic01.ps.gz" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>gallium.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>~fpottier/<allowbreak/>publis/<allowbreak/>fpottier-ic01.<allowbreak/>ps.<allowbreak/>gz</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid8" type="article" rend="foot" n="footcite:2003-Pottier-Simonet-TOPLAS">
      <identifiant type="doi" value="10.1145/596980.596983"/>
      <analytic>
        <title level="a">Information Flow Inference for ML</title>
        <author>
          <persName key="gallium-2014-idp67496">
            <foreName>François</foreName>
            <surname>Pottier</surname>
            <initial>F.</initial>
          </persName>
          <persName>
            <foreName>Vincent</foreName>
            <surname>Simonet</surname>
            <initial>V.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="j">ACM Transactions on Programming Languages and Systems</title>
        <imprint>
          <biblScope type="volume">25</biblScope>
          <biblScope type="number">1</biblScope>
          <dateStruct>
            <month>January</month>
            <year>2003</year>
          </dateStruct>
          <biblScope type="pages">117–158</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/596980.596983" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>596980.<allowbreak/>596983</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid4" type="inproceedings" rend="foot" n="footcite:1997-Remy-Vouillon">
      <analytic>
        <title level="a">Objective ML: A simple object-oriented extension to ML</title>
        <author>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
          <persName>
            <foreName>Jérôme</foreName>
            <surname>Vouillon</surname>
            <initial>J.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">24th ACM Conference on Principles of Programming Languages</title>
        <imprint>
          <publisher>
            <orgName>ACM Press</orgName>
          </publisher>
          <dateStruct>
            <year>1997</year>
          </dateStruct>
          <biblScope type="pages">40–53</biblScope>
          <ref xlink:href="http://gallium.inria.fr/~remy/ftp/objective-ml!popl97.pdf" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>gallium.<allowbreak/>inria.<allowbreak/>fr/<allowbreak/>~remy/<allowbreak/>ftp/<allowbreak/>objective-ml!popl97.<allowbreak/>pdf</ref>
        </imprint>
      </monogr>
    </biblStruct>
    
    <biblStruct id="gallium-2016-bid15" type="inproceedings" rend="foot" n="footcite:2015-Scherer-Remy-ICFP">
      <identifiant type="doi" value="10.1145/2784731.2784757"/>
      <analytic>
        <title level="a">Which simple types have a unique inhabitant?</title>
        <author>
          <persName key="gallium-2014-idp84504">
            <foreName>Gabriel</foreName>
            <surname>Scherer</surname>
            <initial>G.</initial>
          </persName>
          <persName key="gallium-2014-idp70256">
            <foreName>Didier</foreName>
            <surname>Rémy</surname>
            <initial>D.</initial>
          </persName>
        </author>
      </analytic>
      <monogr>
        <title level="m">ICFP'15: 20th International Conference on Functional Programming</title>
        <imprint>
          <publisher>
            <orgName>ACM Press</orgName>
          </publisher>
          <dateStruct>
            <year>2015</year>
          </dateStruct>
          <biblScope type="pages">243–255</biblScope>
          <ref xlink:href="http://dx.doi.org/10.1145/2784731.2784757" location="extern" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://<allowbreak/>dx.<allowbreak/>doi.<allowbreak/>org/<allowbreak/>10.<allowbreak/>1145/<allowbreak/>2784731.<allowbreak/>2784757</ref>
        </imprint>
      </monogr>
    </biblStruct>
  </biblio>
</raweb>
